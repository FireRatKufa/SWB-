<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FR_Kufa作|確率計算機β版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Slide-in panel styles */
        .slide-in-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 100%;
            max-width: 400px; /* Adjust as needed */
            height: 100%;
            background-color: rgba(31, 41, 55, 0.95); /* Gray-800 with transparency */
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
        }
        .slide-in-panel.open {
            transform: translateX(0);
        }

        /* Accordion transition styles */
        .accordion-content {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
        }
        .accordion-content.open {
            /* Increased max-height to ensure all content is visible */
            max-height: 9000px; /* Sufficiently large value to prevent cutoff for many cards */
            opacity: 1;
        }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
</head>
<body class="bg-gray-900 text-white">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // Define CLASS_FEATURES_DEFINITIONS outside App component for reusability and clarity
        const CLASS_FEATURES_DEFINITIONS = {
            'witchSpellboost': {
                displayName: '追加スペルブースト',
                class: 'Witch',
                defaultData: { amount: 0 },
                // render function now includes the delete button
                render: (cardId, featureData, updateCardType, removeFeature) => (
                    <div className="relative flex items-center gap-2 p-2 bg-gray-700 rounded-md col-span-full">
                        <div className="flex-1 flex flex-col">
                            <label htmlFor={`spellboostAmount-${cardId}`} className="text-xs font-semibold text-gray-300 mb-1">ウィッチ特性: 追加スペルブースト量</label>
                            <input
                                type="number"
                                id={`spellboostAmount-${cardId}`}
                                value={featureData.amount}
                                onChange={(e) => updateCardType(cardId, 'classFeatures', { type: 'witchSpellboost', amount: parseInt(e.target.value) || 0 })}
                                className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                min="0"
                            />
                        </div>
                        <button
                            onClick={() => removeFeature(cardId, 'witchSpellboost')}
                            className="absolute top-1 right-1 text-red-400 hover:text-red-200 transition duration-200 p-1 rounded-full hover:bg-red-800"
                            title="この特性を削除"
                        >
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                ),
                validate: (card, featureData) => {
                    if (isNaN(featureData.amount) || featureData.amount < 0) {
                        return `カード「${card.name || '名称未設定'}」の追加スペルブースト量は0以上の数字で指定してください。`;
                    }
                    return null;
                }
            },
            'elfTokenGeneration': {
                displayName: 'トークン生成',
                class: 'Elf',
                defaultData: { generates: true, cost: 0, count: 0 }, // Removed atEndOfTurn
                // render function now includes the delete button
                render: (cardId, featureData, updateCardType, removeFeature) => (
                    <div className="relative flex flex-col p-2 bg-gray-700 rounded-md col-span-full">
                        <div className="flex justify-between items-center mb-1">
                            <label className="inline-flex items-center text-xs font-semibold text-gray-300">
                                <input
                                    type="checkbox"
                                    checked={featureData.generates}
                                    onChange={(e) => updateCardType(cardId, 'classFeatures', { type: 'elfTokenGeneration', generates: e.target.checked, cost: featureData.cost, count: featureData.count })}
                                    className="form-checkbox text-purple-500 focus:ring-purple-500 rounded"
                                />
                                <span className="ml-2">エルフ特性: トークン生成</span>
                            </label>
                            <button
                                onClick={() => removeFeature(cardId, 'elfTokenGeneration')}
                                className="absolute top-1 right-1 text-red-400 hover:text-red-200 transition duration-200 p-1 rounded-full hover:bg-red-800"
                                title="この特性を削除"
                            >
                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>
                        {featureData.generates && (
                            <div className="flex flex-col sm:flex-row gap-2 mt-2">
                                <div className="flex-1">
                                    <label htmlFor={`tokenCost-${cardId}`} className="text-xs font-semibold text-gray-300 mb-1">生成トークンコスト</label>
                                    <input
                                        type="number"
                                        id={`tokenCost-${cardId}`}
                                        value={featureData.cost}
                                        onChange={(e) => updateCardType(cardId, 'classFeatures', { type: 'elfTokenGeneration', generates: featureData.generates, cost: parseInt(e.target.value) || 0, count: featureData.count })}
                                        className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm w-full"
                                        min="0"
                                    />
                                </div>
                                <div className="flex-1">
                                    <label htmlFor={`tokenCount-${cardId}`} className="text-xs font-semibold text-gray-300 mb-1">生成トークン枚数</label>
                                    <input
                                        type="number"
                                        id={`tokenCount-${cardId}`}
                                        value={featureData.count}
                                        onChange={(e) => updateCardType(cardId, 'classFeatures', { type: 'elfTokenGeneration', generates: featureData.generates, cost: featureData.cost, count: parseInt(e.target.value) || 0 })}
                                        className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm w-full"
                                        min="0"
                                    />
                                </div>
                                {/* Removed "ターン終了時生成" checkbox */}
                            </div>
                        )}
                    </div>
                ),
                validate: (card, featureData) => {
                    if (featureData.generates) {
                        if (isNaN(featureData.cost) || featureData.cost < 0) {
                            return `カード「${card.name || '名称未設定'}」の生成トークンコストは0以上の数字で指定してください。`;
                        }
                        if (isNaN(featureData.count) || featureData.count < 0) {
                            return `カード「${card.name || '名称未設定'}」の生成トークン枚数は0以上の数字で指定してください。`;
                        }
                    }
                    return null;
                }
            },
            'nemesisArtifactGeneration': {
                displayName: 'AF生成',
                class: 'Nemesis',
                defaultData: { generatesFutureCore: false, generatesPastCore: false, futureCoreCount: 1, pastCoreCount: 1 },
                render: (cardId, featureData, updateCardType, removeFeature) => (
                    <div className="relative flex flex-col p-2 bg-gray-700 rounded-md col-span-full">
                        <div className="flex justify-between items-center mb-1">
                            <label className="inline-flex items-center text-xs font-semibold text-gray-300">
                                <span className="ml-2">ネメシス特性: AF生成</span>
                            </label>
                            <button
                                onClick={() => removeFeature(cardId, 'nemesisArtifactGeneration')}
                                className="absolute top-1 right-1 text-red-400 hover:text-red-200 transition duration-200 p-1 rounded-full hover:bg-red-800"
                                title="この特性を削除"
                            >
                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>
                        <div className="flex flex-col sm:flex-row gap-2 mt-2">
                            <div className="flex-1">
                                <label className="inline-flex items-center text-sm font-medium text-gray-300 mb-1">
                                    <input
                                        type="checkbox"
                                        checked={featureData.generatesFutureCore}
                                        onChange={(e) => updateCardType(cardId, 'classFeatures', { type: 'nemesisArtifactGeneration', generatesFutureCore: e.target.checked, generatesPastCore: featureData.generatesPastCore, futureCoreCount: featureData.futureCoreCount, pastCoreCount: featureData.pastCoreCount })}
                                        className="form-checkbox text-purple-500 focus:ring-purple-500 rounded"
                                    />
                                    <span className="ml-2">フューチャー・コア生成</span>
                                </label>
                                {featureData.generatesFutureCore && (
                                    <input
                                        type="number"
                                        value={featureData.futureCoreCount}
                                        onChange={(e) => updateCardType(cardId, 'classFeatures', { type: 'nemesisArtifactGeneration', generatesFutureCore: true, generatesPastCore: featureData.generatesPastCore, futureCoreCount: parseInt(e.target.value) || 0, pastCoreCount: featureData.pastCoreCount })}
                                        className="p-1 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm w-16 ml-2"
                                        min="0"
                                    />
                                )}
                            </div>
                            <div className="flex-1">
                                <label className="inline-flex items-center text-sm font-medium text-gray-300 mb-1">
                                    <input
                                        type="checkbox"
                                        checked={featureData.generatesPastCore}
                                        onChange={(e) => updateCardType(cardId, 'classFeatures', { type: 'nemesisArtifactGeneration', generatesFutureCore: featureData.generatesFutureCore, generatesPastCore: e.target.checked, futureCoreCount: featureData.futureCoreCount, pastCoreCount: featureData.pastCoreCount })}
                                        className="form-checkbox text-purple-500 focus:ring-purple-500 rounded"
                                    />
                                    <span className="ml-2">パスト・コア生成</span>
                                </label>
                                {featureData.generatesPastCore && (
                                    <input
                                        type="number"
                                        value={featureData.pastCoreCount}
                                        onChange={(e) => updateCardType(cardId, 'classFeatures', { type: 'nemesisArtifactGeneration', generatesFutureCore: featureData.generatesFutureCore, generatesPastCore: true, futureCoreCount: featureData.futureCoreCount, pastCoreCount: parseInt(e.target.value) || 0 })}
                                        className="p-1 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm w-16 ml-2"
                                        min="0"
                                    />
                                )}
                            </div>
                        </div>
                    </div>
                ),
                validate: (card, featureData) => {
                    if (!featureData.generatesFutureCore && !featureData.generatesPastCore) {
                        return `カード「${card.name || '名称未設定'}」のAF生成特性は、フューチャー・コアまたはパスト・コアのいずれか、あるいは両方を生成するように設定してください。`;
                    }
                    if (featureData.generatesFutureCore && (isNaN(featureData.futureCoreCount) || featureData.futureCoreCount < 0)) {
                        return `カード「${card.name || '名称未設定'}」のフューチャー・コア生成枚数は0以上の数字で指定してください。`;
                    }
                    if (featureData.generatesPastCore && (isNaN(featureData.pastCoreCount) || featureData.pastCoreCount < 0)) {
                        return `カード「${card.name || '名称未設定'}」のパスト・コア生成枚数は0以上の数字で指定してください。`;
                    }
                    return null;
                }
            },
            'nemesisAFCopy': {
                displayName: 'AFコピー',
                class: 'Nemesis',
                defaultData: { copyCount: 1 },
                render: (cardId, featureData, updateCardType, removeFeature) => (
                    <div className="relative flex items-center gap-2 p-2 bg-gray-700 rounded-md col-span-full">
                        <div className="flex-1 flex flex-col">
                            <label htmlFor={`afCopyCount-${cardId}`} className="text-xs font-semibold text-gray-300 mb-1">ネメシス特性: AFコピー枚数</label>
                            <input
                                type="number"
                                id={`afCopyCount-${cardId}`}
                                value={featureData.copyCount}
                                onChange={(e) => updateCardType(cardId, 'classFeatures', { type: 'nemesisAFCopy', copyCount: parseInt(e.target.value) || 0 })}
                                className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                min="1"
                                max="3"
                            />
                        </div>
                        <button
                            onClick={() => removeFeature(cardId, 'nemesisAFCopy')}
                            className="absolute top-1 right-1 text-red-400 hover:text-red-200 transition duration-200 p-1 rounded-full hover:bg-red-800"
                            title="この特性を削除"
                        >
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                ),
                validate: (card, featureData) => {
                    if (isNaN(featureData.copyCount) || featureData.copyCount < 1 || featureData.copyCount > 3) {
                        return `カード「${card.name || '名称未設定'}」のAFコピー枚数は1から3までの数字で指定してください。`;
                    }
                    return null;
                }
            },
            'nightmareFaithValue': {
                displayName: '信仰値増加',
                class: 'Nightmare',
                defaultData: { amount: 1 },
                render: (cardId, featureData, updateCardType, removeFeature) => (
                    <div className="relative flex items-center gap-2 p-2 bg-gray-700 rounded-md col-span-full">
                        <div className="flex-1 flex flex-col">
                            <label htmlFor={`faithValueAmount-${cardId}`} className="text-xs font-semibold text-gray-300 mb-1">ナイトメア特性: 信仰値増加量</label>
                            <input
                                type="number"
                                id={`faithValueAmount-${cardId}`}
                                value={featureData.amount}
                                onChange={(e) => updateCardType(cardId, 'classFeatures', { type: 'nightmareFaithValue', amount: parseInt(e.target.value) || 0 })}
                                className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                min="0"
                            />
                        </div>
                        <button
                            onClick={() => removeFeature(cardId, 'nightmareFaithValue')}
                            className="absolute top-1 right-1 text-red-400 hover:text-red-200 transition duration-200 p-1 rounded-full hover:bg-red-800"
                            title="この特性を削除"
                        >
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                ),
                validate: (card, featureData) => {
                    if (isNaN(featureData.amount) || featureData.amount < 0) {
                        return `カード「${card.name || '名称未設定'}」の信仰値増加量は0以上の数字で指定してください。`;
                    }
                    return null;
                }
            }
        };

        const SPECIAL_CARD_NAMES = {
            HOLY_TREE_STAFF: {
                name: '聖樹の杖',
                defaultCount: 3,
                defaultCost: 3,
                defaultDrawCount: 0,
                defaultMulliganKeepCount: 0,
                defaultPlayPriorityTurns: [],
                defaultType: 'アミュレット',
                classFeatures: [], // No specific class features added by default for this, its effect is global.
            },
            TITANIA: {
                name: '翅の女王・ティターニア',
                defaultCount: 3,
                defaultCost: 4,
                defaultDrawCount: 0,
                defaultMulliganKeepCount: 0,
                defaultPlayPriorityTurns: [],
                defaultType: 'フォロワー',
                // Titania's specific effect is now handled by a custom flag for end-of-turn token generation
                classFeatures: [{ type: 'elfTokenGeneration', generates: true, cost: 1, count: 1, atEndOfTurn: true }],
            },
        };

        // Define the properties of generated Artifact Core cards
        const NEMESIS_GENERATED_ARTIFACTS = {
            FUTURE_CORE: {
                name: 'フューチャー・コア',
                cost: 1,
                type: 'アミュレット',
                isArtifact: true,
                isPlayable: false, // These cannot be played directly, only fused
                isToken: true, // Mark as token to distinguish from deck cards
            },
            PAST_CORE: {
                name: 'パスト・コア',
                cost: 1,
                type: 'アミュレット',
                isArtifact: true,
                isPlayable: false, // These cannot be played directly, only fused
                isToken: true, // Mark as token to distinguish from deck cards
            },
            // Adding a new AF for the fusion result
            ATTACK_ARTIFACT: {
                name: 'アタックアーティファクト',
                cost: 3,
                type: 'フォロワー',
                isArtifact: true,
                isPlayable: true,
                isToken: true, // Generated from fusion, so it's a token
            },
            CASTLE_ARTIFACT: {
                name: 'キャッスルアーティファクト',
                cost: 3,
                type: 'フォロワー',
                isArtifact: true,
                isPlayable: true,
                isToken: true, // Generated from fusion, so it's a token
            },
            // デストロイアーティファクトの定義
            DESTROY_ARTIFACT_ALPHA: {
                name: 'デストロイアーティファクトα',
                cost: 5,
                type: 'フォロワー',
                isArtifact: true,
                isPlayable: true,
                isToken: true,
                fusionRequirements: {
                    type: ['デストロイアーティファクトβ', 'デストロイアーティファクトγ'],
                    count: 2
                }
            },
            DESTROY_ARTIFACT_BETA: {
                name: 'デストロイアーティファクトβ',
                cost: 5,
                type: 'フォロワー',
                isArtifact: true,
                isPlayable: true,
                isToken: true,
            },
            DESTROY_ARTIFACT_GAMMA: {
                name: 'デストロイアーティファクトγ',
                cost: 5,
                type: 'フォロワー',
                isArtifact: true,
                isPlayable: true,
                isToken: true,
            },
            EXCEED_ARTIFACT_OMEGA: {
                name: 'イクシードアーティファクトΩ',
                cost: 10,
                type: 'フォロワー',
                isArtifact: true,
                isPlayable: true,
                isToken: true,
            }
        };

        const DESTROY_ARTIFACT_OPTIONS = [
            { value: 'alpha', name: 'デストロイアーティファクトα' },
            { value: 'beta', name: 'デストロイアーティファクトβ' },
            { value: 'gamma', name: 'デストロイアーティファクトγ' },
        ];

        // Define the desired class order for display
        const CLASS_DISPLAY_ORDER = ['Elf', 'Royal', 'Witch', 'Dragon', 'Nightmare', 'Bishop', 'Nemesis'];

        // Map English class names to Katakana
        const CLASS_NAME_MAP = {
            'Elf': 'エルフ',
            'Royal': 'ロイヤル',
            'Witch': 'ウィッチ',
            'Dragon': 'ドラゴン',
            'Nightmare': 'ナイトメア',
            'Bishop': 'ビショップ',
            'Nemesis': 'ネメシス',
        };

        // Main application component
        const App = () => {
            // Fixed deck size
            const deckSize = 40;
            // Max turns changed to 15
            const maxTurns = 15;
            // Fixed number of simulations
            const numSimulations = 10000;
            // Hand size limit
            const handLimit = 9;
            // Max number of locally saved results
            const maxSavedResults = 10;
            // Max number of locally saved decks
            const maxSavedDecks = 10;

            // Calculation Modes
            const CALC_MODE_SINGLE = 'single';
            const CALC_MODE_COMBINATION = 'combination';

            // Match Types for combination mode
            const MATCH_TYPE_AT_LEAST = 'atLeast';
            const MATCH_TYPE_EXACTLY = 'exactly';

            // Match Locations for combination mode
            const MATCH_LOCATION_HAND = 'hand';
            const MATCH_LOCATION_DECK = 'deck';

            // localStorageから初期状態を読み込むヘルパー関数
            const loadStateFromLocalStorage = (key, defaultValue) => {
                try {
                    const serializedState = localStorage.getItem(key);
                    if (serializedState === null) {
                        return defaultValue;
                    }
                    const parsedState = JSON.parse(serializedState);
                    // Backward compatibility for old cardType structure
                    return parsedState.map(card => {
                        // If old properties exist, convert them to classFeatures
                        if (card.spellboostIncreaseAmount !== undefined || card.generatesToken !== undefined) {
                            const newFeatures = card.classFeatures || [];
                            if (card.spellboostIncreaseAmount !== undefined) {
                                newFeatures.push({ type: 'witchSpellboost', amount: card.spellboostIncreaseAmount });
                            }
                            if (card.generatesToken !== undefined) {
                                // For backward compatibility, if old generatesToken existed, add elfTokenGeneration.
                                // The atEndOfTurn property for generic elfTokenGeneration is now removed from UI,
                                // but we keep it for Titania's specific case.
                                newFeatures.push({ type: 'elfTokenGeneration', generates: card.generatesToken, cost: card.tokenCost, count: card.tokenCount, atEndOfTurn: card.generatesTokenAtEndOfTurn || false });
                            }
                            // Delete old properties to clean up
                            const { spellboostIncreaseAmount, generatesToken, tokenCost, tokenCount, generatesTokenAtEndOfTurn, ...rest } = card;
                            return { ...rest, classFeatures: newFeatures };
                        }
                        // Ensure classFeatures array exists for new cards or existing without features
                        return { ...card, classFeatures: card.classFeatures || [] };
                    });
                } catch (error) {
                    console.error("Error loading state from localStorage", error);
                    return defaultValue;
                }
            };

            // Default card types for initial load
            const defaultCardTypes = [
                // Changed default playPriorityTurns from [5] to []
                { id: 1, name: 'キーカードA', count: 3, cost: 3, drawCount: 0, mulliganKeepCount: 1, playPriorityTurns: [], type: 'フォロワー', classFeatures: [] },
                { id: 2, name: 'ドローカードA', count: 3, cost: 1, drawCount: 1, mulliganKeepCount: 0, playPriorityTurns: [], type: 'スペル', classFeatures: [] },
                { id: 3, name: 'その他カード', count: 34, cost: 1, drawCount: 0, mulliganKeepCount: 0, playPriorityTurns: [], type: 'アミュレット', classFeatures: [] },
            ];

            // Simulation settings state
            const [cardTypes, setCardTypes] = useState(() =>
                loadStateFromLocalStorage('cardTypes', defaultCardTypes)
            );
            const [calculationMode, setCalculationMode] = useState(CALC_MODE_SINGLE); // Changed default to CALC_MODE_SINGLE
            const [selectedTargetCardTypeId, setSelectedTargetCardTypeId] = useState(cardTypes[0]?.id || null);
            const [combinationSets, setCombinationSets] = useState([
                {
                    id: Date.now(),
                    name: '組み合わせ1',
                    isActive: true,
                    conditions: [
                        { id: Date.now() + 1, cardTypeId: cardTypes[0]?.id || null, targetCount: 1, matchType: MATCH_TYPE_AT_LEAST, matchLocation: MATCH_LOCATION_HAND }
                    ]
                }
            ]);
            const [isFirstPlayer, setIsFirstPlayer] = useState(true);
            const [extraPpTurn1, setExtraPpTurn1] = useState(5);
            const [extraPpTurn2, setExtraPpTurn2] = useState(6);
            const [selectedClass, setSelectedClass] = useState(''); 
            
            // New state for multiple destroy artifact fusion choices
            const [destroyArtifactFusions, setDestroyArtifactFusions] = useState({
                1: 'beta', // Default for 1st fusion
                2: 'beta', // Default for 2nd fusion
                3: 'beta', // Default for 3rd fusion
            });

            // UI state for collapsible sections
            const [showGameSettings, setShowGameSettings] = useState(true);
            const [showDeckSettings, setShowDeckSettings] = useState(true);
            const [showDeckSettingsUsage, setShowDeckSettingsUsage] = useState(false);
            const [showCalculationMethod, setShowCalculationMethod] = useState(false); // Default to false
            const [showDeckManagement, setShowDeckManagement] = useState(true); // New section for deck management
            const [showSpecialEffectCards, setShowSpecialEffectCards] = useState(false); // Changed to false
            const [showResultsInterpretation, setShowResultsInterpretation] = useState(false); // Changed to false
            const [showClassFeatureManagement, setShowClassFeatureManagement] = useState(false); // Changed to false
            
            // Simulation results and UI state
            const [results, setResults] = useState([]);
            const [loading, setLoading] = useState(false);
            const [message, setMessage] = useState('');

            // Locally saved results state (これは引き続きlocalStorageに保存する)
            const [savedSimulations, setSavedSimulations] = useState(() =>
                loadStateFromLocalStorage('savedSimulations', [])
            );
            const [saveDescription, setSaveDescription] = useState('');
            // 比較対象として読み込まれた保存済みアイテム全体を保持する新しいステート
            const [comparisonSavedItem, setComparisonSavedItem] = useState(null); 
            const [showSavedResultsPanel, setShowSavedResultsPanel] = useState(false);

            // New state for multiple saved decks
            const [savedDecks, setSavedDecks] = useState(() =>
                loadStateFromLocalStorage('savedDecks', [])
            );
            const [currentDeckSaveName, setCurrentDeckSaveName] = useState(''); // Name for saving the current deck
            const [showSavedDecksPanel, setShowSavedDecksPanel] = useState(false); // Panel for saved decks

            // State for adding/removing class features
            const [selectedCardForFeature, setSelectedCardForFeature] = useState(cardTypes[0]?.id || null);
            const [selectedClassFeatureType, setSelectedClassFeatureType] = useState('');

            // Ref for scrolling to specific card types
            const cardRefs = useRef(new Map());

            const setCardRef = useCallback((node, id) => {
                if (node) {
                    cardRefs.current.set(id, node);
                } else {
                    cardRefs.current.delete(id);
                }
            }, []);

            // Calculate total card count in deck in real-time
            const totalCurrentDeckCount = cardTypes.reduce((sum, ct) => sum + (parseInt(ct.count) || 0), 0);

            // selectedTargetCardTypeIdとcombinationSetsのcardTypeIdがcardTypesの更新に追従するように
            useEffect(() => {
                if (!selectedTargetCardTypeId && cardTypes.length > 0) {
                    setSelectedTargetCardTypeId(cardTypes[0].id);
                } else if (selectedTargetCardTypeId && !cardTypes.some(ct => ct.id === selectedTargetCardTypeId)) {
                    // 選択されていたカードが削除された場合、最初のカードを選択し直す
                    setSelectedTargetCardTypeId(cardTypes.length > 0 ? cardTypes[0].id : null);
                }
                // Update selected card for feature management
                if (!selectedCardForFeature && cardTypes.length > 0) {
                    setSelectedCardForFeature(cardTypes[0].id);
                } else if (selectedCardForFeature && !cardTypes.some(ct => ct.id === selectedCardForFeature)) {
                    setSelectedCardForFeature(cardTypes.length > 0 ? cardTypes[0].id : null);
                }


                setCombinationSets(prevSets => {
                    if (cardTypes.length === 0) {
                        return prevSets.map(set => ({
                            ...set,
                            conditions: set.conditions.map(cond => ({ ...cond, cardTypeId: null }))
                        }));
                    }
                    return prevSets.map(set => ({
                        ...set,
                        conditions: set.conditions.map(cond => {
                            if (!cardTypes.some(ct => ct.id === cond.cardTypeId)) {
                                return { ...cond, cardTypeId: cardTypes[0].id };
                            }
                            // matchLocationが未定義の場合のデフォルト設定 (既存の保存データ対応)
                            if (cond.matchLocation === undefined) {
                                return { ...cond, matchLocation: MATCH_LOCATION_HAND };
                            }
                            return cond;
                        })
                    }));
                });
            }, [cardTypes, selectedTargetCardTypeId, selectedCardForFeature]);

            // cardTypesが変更されたときにlocalStorageに保存する
            useEffect(() => {
                localStorage.setItem('cardTypes', JSON.stringify(cardTypes));
            }, [cardTypes]);

            // savedSimulationsが変更されたときにlocalStorageに保存する
            useEffect(() => {
                localStorage.setItem('savedSimulations', JSON.stringify(savedSimulations));
            }, [savedSimulations]);

            // savedDecksが変更されたときにlocalStorageに保存する
            useEffect(() => {
                localStorage.setItem('savedDecks', JSON.stringify(savedDecks));
            }, [savedDecks]);


            const addCardType = () => {
                // Initialize playPriorityTurns as an empty array for new cards
                setCardTypes([...cardTypes, { id: Date.now(), name: '', count: 3, cost: 1, drawCount: 0, mulliganKeepCount: 0, playPriorityTurns: [], type: 'フォロワー', classFeatures: [] }]);
            };

            const updateCardType = (id, field, value) => {
                setCardTypes(cardTypes.map(cardType => {
                    if (cardType.id === id) {
                        if (field === 'playPriorityTurns') {
                            const currentTurns = cardType.playPriorityTurns;
                            const newTurns = currentTurns.includes(value)
                                ? currentTurns.filter(turn => turn !== value)
                                : [...currentTurns, value].sort((a, b) => a - b);
                            return { ...cardType, [field]: newTurns };
                        }
                        // Handle numeric inputs
                        if (['count', 'cost', 'drawCount', 'mulliganKeepCount'].includes(field)) {
                            return { ...cardType, [field]: parseInt(value) || 0 };
                        }
                        // Handle classFeatures update
                        if (field === 'classFeatures') {
                            const featureToUpdate = value; // value is an object like { type: 'witchSpellboost', amount: 5 }
                            const existingFeatures = cardType.classFeatures || [];
                            const featureIndex = existingFeatures.findIndex(f => f.type === featureToUpdate.type);

                            let newClassFeatures;
                            if (featureIndex !== -1) {
                                // Update existing feature
                                newClassFeatures = existingFeatures.map((f, idx) =>
                                    idx === featureIndex ? { ...f, ...featureToUpdate } : f
                                );
                            } else {
                                // Add new feature (should not happen if addFeatureToCard is used correctly)
                                newClassFeatures = [...existingFeatures, newFeature];
                            }
                            return { ...cardType, classFeatures: newClassFeatures };
                        }
                        return { ...cardType, [field]: value };
                    }
                    return cardType;
                }));
            };

            const removeCardType = (id) => {
                setCardTypes(cardTypes.filter(cardType => cardType.id !== id));
            };

            const moveCardTypeUp = (id) => {
                setCardTypes(prevCardTypes => {
                    const index = prevCardTypes.findIndex(card => card.id === id);
                    if (index > 0) {
                        const newCardTypes = [...prevCardTypes];
                        [newCardTypes[index - 1], newCardTypes[index]] = [newCardTypes[index], newCardTypes[index - 1]];
                        return newCardTypes;
                    }
                    return prevCardTypes;
                });
            };

            const moveCardTypeDown = (id) => {
                setCardTypes(prevCardTypes => {
                    const index = prevCardTypes.findIndex(card => card.id === id);
                    if (index < prevCardTypes.length - 1) {
                        const newCardTypes = [...prevCardTypes];
                        [newCardTypes[index + 1], newCardTypes[index]] = [newCardTypes[index], newCardTypes[index + 1]];
                        return newCardTypes;
                    }
                    return prevCardTypes;
                });
            };

            // 組み合わせセットの追加/更新/削除
            const addCombinationSet = () => {
                setCombinationSets(prevSets => [
                    ...prevSets,
                    {
                        id: Date.now(),
                        name: `組み合わせ${prevSets.length + 1}`,
                        isActive: true,
                        conditions: [
                            { id: Date.now() + 1, cardTypeId: cardTypes[0]?.id || null, targetCount: 1, matchType: MATCH_TYPE_AT_LEAST, matchLocation: MATCH_LOCATION_HAND }
                        ]
                    }
                ]);
            };

            const updateCombinationSetName = (setId, newName) => {
                setCombinationSets(prevSets => prevSets.map(set =>
                    set.id === setId ? { ...set, name: newName } : set
                ));
            };

            const toggleCombinationSetActivity = (setId) => {
                setCombinationSets(prevSets => prevSets.map(set =>
                    set.id === setId ? { ...set, isActive: !set.isActive } : set
                ));
            };

            const removeCombinationSet = (setId) => {
                setCombinationSets(prevSets => prevSets.filter(set => set.id !== setId));
            };

            // 組み合わせセット内の条件の追加/更新/削除
            const addCombinationCondition = (setId) => {
                setCombinationSets(prevSets => prevSets.map(set =>
                    set.id === setId
                        ? {
                            ...set,
                            conditions: [...set.conditions, { id: Date.now(), cardTypeId: cardTypes[0]?.id || null, targetCount: 1, matchType: MATCH_TYPE_AT_LEAST, matchLocation: MATCH_LOCATION_HAND }]
                        }
                        : set
                ));
            };

            const updateCombinationCondition = (setId, conditionId, field, value) => {
                setCombinationSets(prevSets => prevSets.map(set =>
                    set.id === setId
                        ? {
                            ...set,
                            conditions: set.conditions.map(cond =>
                                cond.id === conditionId ? { ...cond, [field]: value } : cond
                            )
                        }
                        : set
                ));
            };

            const removeCombinationCondition = (setId, conditionId) => {
                setCombinationSets(prevSets => prevSets.map(set =>
                    set.id === setId
                        ? {
                            ...set,
                            conditions: set.conditions.filter(cond => cond.id !== conditionId)
                        }
                        : set
                ));
            };

            // 累計で手札に来たカードの枚数に基づいて組み合わせが揃ったかチェックするヘルパー関数
            // この関数は、その時点でのdrawnCountsとinitialCardCountに基づいて条件が満たされているかを判定する
            const checkCombinationCondition = (drawnCounts, conditions) => {
                if (conditions.length === 0) return false;

                for (const cond of conditions) {
                    if (cond.cardTypeId === null) return false;
                    const cardInDeckData = cardTypes.find(ct => ct.id === cond.cardTypeId);
                    if (!cardInDeckData) return false; // カードデータが見つからない場合は無効

                    const initialCardCount = parseInt(cardInDeckData.count) || 0;
                    const actualDrawnCount = drawnCounts[cond.cardTypeId] || 0;
                    let actualCountToCheck = 0;

                    if (cond.matchLocation === MATCH_LOCATION_HAND) {
                        actualCountToCheck = actualDrawnCount; // 手札に来た枚数
                    } else if (cond.matchLocation === MATCH_LOCATION_DECK) {
                        actualCountToCheck = initialCardCount - actualDrawnCount; // デッキに残っている枚数
                    }
                    
                    if (cond.matchType === MATCH_TYPE_AT_LEAST) {
                        if (actualCountToCheck < cond.targetCount) {
                            return false;
                        }
                    } else if (cond.matchType === MATCH_TYPE_EXACTLY) {
                        if (actualCountToCheck !== cond.targetCount) {
                            return false;
                        }
                    }
                }
                return true;
            };

            // Class Feature Management functions
            const addFeatureToCard = (cardId, featureType) => {
                const featureDef = CLASS_FEATURES_DEFINITIONS[featureType];
                if (!featureDef) {
                    setMessage(`不明なクラス特性タイプ: ${featureType}`);
                    return;
                }

                setCardTypes(prevCardTypes => prevCardTypes.map(cardType => {
                    if (cardType.id === cardId) {
                        const existingFeatures = cardType.classFeatures || [];
                        if (existingFeatures.some(f => f.type === featureType)) {
                            setMessage(`カード「${cardType.name || '名称未設定'}」には既に「${featureDef.displayName}」が追加されています。`);
                            return cardType; // Feature already exists, do nothing
                        }
                        const newFeature = { type: featureType, ...featureDef.defaultData };
                        return { ...cardType, classFeatures: [...existingFeatures, newFeature] };
                    }
                    return cardType;
                }));
                setMessage(`カードに「${featureDef.displayName}」を追加しました。`);
            };

            const removeFeatureFromCard = (cardId, featureType) => {
                const featureDef = CLASS_FEATURES_DEFINITIONS[featureType];
                if (!featureDef) {
                    setMessage(`不明なクラス特性タイプ: ${featureType}`);
                    return;
                }

                setCardTypes(prevCardTypes => prevCardTypes.map(cardType => {
                    if (cardType.id === cardId) {
                        const existingFeatures = cardType.classFeatures || [];
                        const newClassFeatures = existingFeatures.filter(f => f.type !== featureType);
                        if (newClassFeatures.length === existingFeatures.length) {
                            setMessage(`カード「${cardType.name || '名称未設定'}」には「${featureDef.displayName}」が設定されていません。`);
                            return cardType; // Feature not found, do nothing
                        }
                        return { ...cardType, classFeatures: newClassFeatures };
                    }
                    return cardType;
                }));
                setMessage(`カードから「${featureDef.displayName}」を削除しました。`);
            };


            // Main simulation logic
            const runSimulation = useCallback(() => {
                setMessage('');
                setLoading(true);
                
                setResults([]);

                // Input validation
                const totalCardCountInDeck = cardTypes.reduce((sum, ct) => sum + (parseInt(ct.count) || 0), 0);
                if (totalCardCountInDeck !== deckSize) {
                    setMessage(`デッキの合計枚数が${deckSize}枚ではありません。現在: ${totalCardCountInDeck}枚。`);
                    setLoading(false);
                    return;
                }

                // モードごとのバリデーション
                if (calculationMode === CALC_MODE_SINGLE) {
                    if (!selectedTargetCardTypeId) {
                        setMessage('確率を計算する対象カードを選択してください。');
                        setLoading(false);
                        return;
                    }
                } else if (calculationMode === CALC_MODE_COMBINATION) {
                    const activeCombinationSets = combinationSets.filter(set => set.isActive);
                    if (activeCombinationSets.length === 0) {
                        setMessage('有効な組み合わせ条件が1つ以上設定されていません。');
                        setLoading(false);
                        return;
                    }
                    for (const comboSet of activeCombinationSets) {
                        if (comboSet.conditions.length === 0) {
                            setMessage(`組み合わせ「${comboSet.name}」に条件が設定されていません。`);
                            setLoading(false);
                            return;
                        }
                        for (const cond of comboSet.conditions) {
                            if (cond.cardTypeId === null) {
                                setMessage(`組み合わせ「${comboSet.name}」の条件にカードが選択されていません。`);
                                setLoading(false);
                                return;
                            }
                            const cardInDeck = cardTypes.find(ct => ct.id === cond.cardTypeId);
                            if (!cardInDeck) {
                                setMessage(`組み合わせ「${comboSet.name}」に設定されているカード「${cardTypes.find(c => c.id === cond.cardTypeId)?.name || cond.cardTypeId}」がデッキに存在しません。`);
                                setLoading(false);
                                return;
                            }
                            // targetCountの最小値と最大値を検証
                            if (isNaN(cond.targetCount) || cond.targetCount < 0 || cond.targetCount > (cardInDeck.count || 0)) {
                                setMessage(`カード「${cardInDeck.name || '名称未設定'}」の枚数は0から採用枚数（${cardInDeck.count}）までの数字で指定してください。`);
                                setLoading(false);
                                return;
                            }
                        }
                    }
                }


                // Validate extra PP turns
                if (!isFirstPlayer) {
                    const turn1 = parseInt(extraPpTurn1);
                    const turn2 = parseInt(extraPpTurn2);

                    if (isNaN(turn1) || turn1 < 1 || turn1 > 5) {
                        setMessage('エクストラPP使用ターン1は1から5までの数字で指定してください。');
                        setLoading(false);
                        return;
                    }
                    if (isNaN(turn2) || turn2 < 6 || turn2 > maxTurns) {
                        setMessage(`エクストラPP使用ターン2は6から${maxTurns}までの数字で指定してください。`);
                        setLoading(false);
                        return;
                    }
                    if (turn1 === turn2) {
                        setMessage('エクストラPP使用ターン1とターン2は異なるターンを指定してください。');
                        setLoading(false);
                        return;
                    }
                }

                // Validate mulligan keep counts and play priority turns for each card type
                for (const cardType of cardTypes) {
                    const keepCount = parseInt(cardType.mulliganKeepCount);
                    const deckCount = parseInt(cardType.count);
                    if (isNaN(keepCount) || keepCount < 0 || keepCount > 3 || keepCount > deckCount) {
                        setMessage(`カード「${cardType.name || '名称未設定'}」のマリガンキープ枚数は0から3までの数字で、採用枚数以下で指定してください。`);
                        setLoading(false);
                        return;
                    }

                    if (!Array.isArray(cardType.playPriorityTurns)) {
                        setMessage(`カード「${cardType.name || '名称未設定'}」のプレイ優先ターン設定が不正です。`);
                        setLoading(false);
                        return;
                    }
                    for (const turn of cardType.playPriorityTurns) {
                        if (isNaN(turn) || turn < 1 || turn > 10) {
                            setMessage(`カード「${cardType.name || '名称未設定'}」のプレイ優先ターンは1から10までの数字で指定してください。`);
                            setLoading(false);
                            return;
                        }
                    }

                    // Validate class features dynamically
                    if (cardType.classFeatures) {
                        for (const feature of cardType.classFeatures) {
                            const validationError = CLASS_FEATURES_DEFINITIONS[feature.type]?.validate(cardType, feature);
                            if (validationError) {
                                setMessage(validationError);
                                setLoading(false);
                                return;
                            }
                        }
                    }
                }

                // シミュレーション結果を格納する配列をモードによって切り替え
                let simulationCounts;
                let maxTargetCopiesInDeck = 0; // 単一カードモード用
                if (calculationMode === CALC_MODE_SINGLE) {
                    const selectedTargetCard = cardTypes.find(ct => ct.id === selectedTargetCardTypeId);
                    maxTargetCopiesInDeck = parseInt(selectedTargetCard?.count || 0);
                    simulationCounts = Array(maxTurns + 1).fill(0).map(() => Array(maxTargetCopiesInDeck + 1).fill(0));
                } else { // CALC_MODE_COMBINATION
                    // 複数の組み合わせセットに対応
                    simulationCounts = {};
                    combinationSets.filter(set => set.isActive).forEach(set => {
                        // 各ターンでの条件達成数を記録
                        simulationCounts[set.id] = Array(maxTurns + 1).fill(0);
                    });
                }

                const isWitchClassSelected = selectedClass === 'Witch';
                const isElfClassSelected = selectedClass === 'Elf'; // エルフクラスの選択状態
                const isNemesisClassSelected = selectedClass === 'Nemesis'; // ネメシスクラスの選択状態
                const isNightmareClassSelected = selectedClass === 'Nightmare'; // ナイトメアクラスの選択状態

                let totalSpellsPlayedPerTurnRawSum = Array(maxTurns + 1).fill(0);
                let totalCumulativeSpellsPlayedRawSum = Array(maxTurns + 1).fill(0);
                let totalCardsPlayedPerTurnRawSum = Array(maxTurns + 1).fill(0); // エルフ用: ターンごとのプレイ枚数合計
                let totalFaithValueRawSum = Array(maxTurns + 1).fill(0); // ナイトメア用: 信仰値合計

                let simulationsCompleted = 0;


                const performSingleSimulationCorrectedSpellboost = () => {
                    let deck = [];
                    cardTypes.forEach(cardType => {
                        for (let k = 0; k < (parseInt(cardType.count) || 0); k++) {
                            deck.push({ 
                                id: cardType.id, name: cardType.name, cost: parseInt(cardType.cost) || 0, 
                                drawCount: parseInt(cardType.drawCount) || 0,
                                mulliganKeepCount: parseInt(cardType.mulliganKeepCount) || 0,
                                playPriorityTurns: [...(cardType.playPriorityTurns || [])], // Ensure it's an array
                                type: cardType.type,
                                classFeatures: JSON.parse(JSON.stringify(cardType.classFeatures || [])), // Deep copy features
                                isToken: false, // Flag to distinguish from generated tokens
                                isPlayable: true, // Default to true, overridden by NEMESIS_GENERATED_ARTIFACTS if applicable
                            });
                        }
                    });

                    for (let j = deck.length - 1; j > 0; j--) {
                        const k = Math.floor(Math.random() * (j + 1));
                        [deck[j], deck[k]] = [deck[k], deck[j]];
                    }

                    let hand = [];
                    let pp = 0;
                    let currentDeck = [...deck];
                    
                    let cardsDrawnCumulatively = {}; // 累計で引いたカードの枚数を追跡
                    cardTypes.forEach(cardType => { // 全てのカードタイプを初期化
                        cardsDrawnCumulatively[cardType.id] = 0;
                    });

                    let totalTargetCardsDrawn = 0; // 単一カードモード用

                    let spellsPlayedPerTurnInSim = Array(maxTurns + 1).fill(0);
                    let cumulativeSpellsPlayedInSim = Array(maxTurns + 1).fill(0);
                    let cardsPlayedPerTurnInSim = Array(maxTurns + 1).fill(0); // エルフ用: ターンごとのプレイ枚数
                    let faithValueInSim = 0; // ナイトメア用: 信仰値

                    let holyTreeStaffPlayedThisSim = false; // 聖樹の杖がこのシミュレーションでプレイされたか
                    let titaniaEffectActiveThisGame = false; // 翅の女王・ティターニアの効果がゲーム中にアクティブか

                    let extraPpUsed1 = false;
                    let extraPpUsed2 = false;

                    const drawCardAndUpdateCumulative = () => {
                        if (currentDeck.length > 0) {
                            const drawnCard = currentDeck.shift();
                            // Only count non-token cards for cumulative drawn counts
                            if (!drawnCard.isToken) {
                                cardsDrawnCumulatively[drawnCard.id] = (cardsDrawnCumulatively[drawnCard.id] || 0) + 1;

                                // 単一カードモードの場合、対象カードの枚数を更新
                                if (calculationMode === CALC_MODE_SINGLE && drawnCard.id === selectedTargetCardTypeId) {
                                    totalTargetCardsDrawn++;
                                }
                            }

                            if (hand.length < handLimit) {
                                hand.push(drawnCard);
                            } else {
                                // Hand is full, card is discarded (but still counted as drawn for cumulative check if not a token)
                            }
                        }
                    };

                    let initialHandCards = [];
                    for (let j = 0; j < 4; j++) {
                        if (currentDeck.length > 0) {
                            initialHandCards.push(currentDeck.shift());
                        }
                    }

                    let keptCardsFromMulligan = [];
                    let returnedToDeckFromMulligan = [];
                    let currentKeptCounts = {};

                    initialHandCards.forEach(card => {
                        const cardTypeId = card.id;
                        const desiredKeepCount = card.mulliganKeepCount;
                        currentKeptCounts[cardTypeId] = currentKeptCounts[cardTypeId] || 0;

                        if (currentKeptCounts[cardTypeId] < desiredKeepCount) {
                            keptCardsFromMulligan.push(card);
                            // Only count non-token cards for cumulative drawn counts
                            if (!card.isToken) {
                                cardsDrawnCumulatively[cardTypeId] = (cardsDrawnCumulatively[cardTypeId] || 0) + 1;
                                // 単一カードモードの場合
                                if (calculationMode === CALC_MODE_SINGLE && cardTypeId === selectedTargetCardTypeId) {
                                    totalTargetCardsDrawn++;
                                }
                            }
                            currentKeptCounts[cardTypeId]++;
                        } else {
                            returnedToDeckFromMulligan.push(card);
                        }
                    });

                    const cardsToDrawAfterMulligan = 4 - keptCardsFromMulligan.length;
                    hand = [...keptCardsFromMulligan];

                    currentDeck = [...currentDeck, ...returnedToDeckFromMulligan];
                    for (let j = currentDeck.length - 1; j > 0; j--) {
                        const k = Math.floor(Math.random() * (j + 1));
                        [currentDeck[j], currentDeck[k]] = [currentDeck[k], currentDeck[j]];
                    }

                    for (let j = 0; j < cardsToDrawAfterMulligan; j++) {
                        drawCardAndUpdateCumulative();
                    }
                    
                    // 0ターン目（初期手札+マリガン後）での組み合わせ/単一カードチェック
                    if (calculationMode === CALC_MODE_COMBINATION) {
                        combinationSets.filter(set => set.isActive).forEach(set => {
                            // 各ターンでの条件達成数を記録するように変更
                            if (checkCombinationCondition(cardsDrawnCumulatively, set.conditions)) {
                                simulationCounts[set.id][0]++;
                            }
                        });
                    } else { // CALC_MODE_SINGLE
                        // 0ターン目の対象カード枚数を記録
                        simulationCounts[0][totalTargetCardsDrawn]++;
                    }

                    if (isWitchClassSelected) {
                        spellsPlayedPerTurnInSim[0] = 0;
                        cumulativeSpellsPlayedInSim[0] = 0;
                    }
                    if (isElfClassSelected) { // エルフ用初期化
                        cardsPlayedPerTurnInSim[0] = 0;
                    }
                    if (isNightmareClassSelected) { // ナイトメア用初期化
                        faithValueInSim = 0;
                    }

                    let destroyArtifactFusionCount = 0; // デストロイアーティファクトの融合回数を追跡

                    for (let turn = 1; turn <= maxTurns; turn++) {
                        let currentTurnSpellsPlayed = 0;
                        let currentTurnCardsPlayed = 0; // エルフ用: このターンにプレイしたカードの枚数

                        let currentMaxPp = Math.min(turn, 10);
                        pp = currentMaxPp;

                        if (!isFirstPlayer) {
                            const parsedExtraPpTurn1 = parseInt(extraPpTurn1);
                            const parsedExtraPpTurn2 = parseInt(extraPpTurn2);

                            const canUseExtraPpAtTurn1 = turn === parsedExtraPpTurn1 && !extraPpUsed1;
                            const canUseExtraPpAtTurn2 = turn === parsedExtraPpTurn2 && !extraPpUsed2;

                            if (canUseExtraPpAtTurn1 || canUseExtraPpAtTurn2) {
                                const potentialPp = pp + 1;
                                const canPlayCardWithExtraPp = hand.some(card =>
                                    card.cost <= potentialPp && card.cost > pp && card.isPlayable !== false // Check isPlayable
                                );

                                if (canPlayCardWithExtraPp) {
                                    pp += 1;
                                    if (turn === parsedExtraPpTurn1) extraPpUsed1 = true;
                                    else if (turn === parsedExtraPpTurn2) extraPpUsed2 = true; 
                                }
                            }
                        }

                        drawCardAndUpdateCumulative();
                        
                        // --- AF融合シミュレーションの追加 (AFアミュレット -> 3コストAFフォロワー) ---
                        if (isNemesisClassSelected) {
                            let afAmuletsInHand;
                            let afFollowersInHand;

                            while (true) {
                                afAmuletsInHand = hand.filter(card => card.isArtifact && card.type === 'アミュレット' && (card.name === NEMESIS_GENERATED_ARTIFACTS.FUTURE_CORE.name || card.name === NEMESIS_GENERATED_ARTIFACTS.PAST_CORE.name));
                                afFollowersInHand = hand.filter(card => card.isArtifact && card.type === 'フォロワー' && (card.name === NEMESIS_GENERATED_ARTIFACTS.ATTACK_ARTIFACT.name || card.name === NEMESIS_GENERATED_ARTIFACTS.CASTLE_ARTIFACT.name));

                                let shouldFuse = false;
                                if (afFollowersInHand.length === 0) {
                                    if (afAmuletsInHand.length >= 2) {
                                        shouldFuse = true;
                                    }
                                } else if (afFollowersInHand.length === 1) {
                                    if (afAmuletsInHand.length >= 4) {
                                        shouldFuse = true;
                                    }
                                }

                                if (shouldFuse) {
                                    // 手札からAFアミュレット2枚を削除
                                    const index1 = hand.findIndex(card => card === afAmuletsInHand[0]);
                                    hand.splice(index1, 1);
                                    const index2 = hand.findIndex(card => card === afAmuletsInHand[1]);
                                    hand.splice(index2, 1);
                                    
                                    // どちらのAFフォロワーに変身するかランダムに決定
                                    const newAF = Math.random() < 0.5 
                                        ? { ...NEMESIS_GENERATED_ARTIFACTS.ATTACK_ARTIFACT }
                                        : { ...NEMESIS_GENERATED_ARTIFACTS.CASTLE_ARTIFACT };
                                    
                                    // 新しいAFフォロワーを手札に追加
                                    if (hand.length < handLimit) {
                                        hand.push(newAF);
                                    }
                                } else {
                                    break;
                                }
                            }
                            
                            // デストロイアーティファクトの融合ロジック (3コストAFフォロワー -> デストロイアーティファクト)
                            while (true) {
                                const afFollowersInHand = hand.filter(card => card.isArtifact && card.type === 'フォロワー' && (card.name === NEMESIS_GENERATED_ARTIFACTS.ATTACK_ARTIFACT.name || card.name === NEMESIS_GENERATED_ARTIFACTS.CASTLE_ARTIFACT.name));
                                
                                // 融合対象となる3コストAFフォロワーが1枚でも手札にあれば融合を試みる
                                const fusionTargetIndex = hand.findIndex(card => afFollowersInHand.includes(card));
                                if (fusionTargetIndex === -1) break; // 融合対象がなければ終了
                                
                                const fusionTarget = hand[fusionTargetIndex];
                                
                                const afAmuletsInHandForDestroy = hand.filter(card => card.isArtifact && card.type === 'アミュレット');
                                const otherAfFollowersInHand = afFollowersInHand.filter(card => card !== fusionTarget);
                                
                                let newDestroyArtifactName = null;
                                let fusionMaterials = [];
                                const fusionChoice = destroyArtifactFusions[destroyArtifactFusionCount + 1] || 'beta';
                                
                                if (fusionChoice === 'alpha') {
                                    // αに変身する場合：3コストAFフォロワー1枚 + 1コストAFアミュレット1枚
                                    if (afAmuletsInHandForDestroy.length >= 1) {
                                        newDestroyArtifactName = NEMESIS_GENERATED_ARTIFACTS.DESTROY_ARTIFACT_ALPHA.name;
                                        fusionMaterials.push(afAmuletsInHandForDestroy[0]);
                                    }
                                } else if (fusionChoice === 'beta') {
                                    // βに変身する場合：3コストAFフォロワー1枚 + 1コストAFアミュレット2枚
                                    if (afAmuletsInHandForDestroy.length >= 2) {
                                        newDestroyArtifactName = NEMESIS_GENERATED_ARTIFACTS.DESTROY_ARTIFACT_BETA.name;
                                        fusionMaterials.push(afAmuletsInHandForDestroy[0], afAmuletsInHandForDestroy[1]);
                                    }
                                } else if (fusionChoice === 'gamma') {
                                    // γに変身する場合：3コストAFフォロワー2枚
                                    if (otherAfFollowersInHand.length >= 1) {
                                        newDestroyArtifactName = NEMESIS_GENERATED_ARTIFACTS.DESTROY_ARTIFACT_GAMMA.name;
                                        fusionMaterials.push(otherAfFollowersInHand[0]);
                                    }
                                }
                                
                                if (newDestroyArtifactName) {
                                    // 融合素材を消費
                                    for(const material of fusionMaterials) {
                                        const materialIndex = hand.indexOf(material);
                                        hand.splice(materialIndex, 1);
                                    }
                                    
                                    // 融合対象のカードを変身させる
                                    const targetIndex = hand.indexOf(fusionTarget);
                                    if (targetIndex !== -1) {
                                        hand.splice(targetIndex, 1);
                                    }

                                    // 新しいデストロイアーティファクトを生成
                                    if (hand.length < handLimit) {
                                        let newDestroyCard;
                                        if (newDestroyArtifactName === NEMESIS_GENERATED_ARTIFACTS.DESTROY_ARTIFACT_ALPHA.name) {
                                            newDestroyCard = { ...NEMESIS_GENERATED_ARTIFACTS.DESTROY_ARTIFACT_ALPHA };
                                        } else if (newDestroyArtifactName === NEMESIS_GENERATED_ARTIFACTS.DESTROY_ARTIFACT_BETA.name) {
                                            newDestroyCard = { ...NEMESIS_GENERATED_ARTIFACTS.DESTROY_ARTIFACT_BETA };
                                        } else { // gamma
                                            newDestroyCard = { ...NEMESIS_GENERATED_ARTIFACTS.DESTROY_ARTIFACT_GAMMA };
                                        }
                                        hand.push(newDestroyCard);
                                        destroyArtifactFusionCount++;
                                    }
                                } else {
                                    break;
                                }
                            }
                        }
                        // --- AF融合シミュレーションの追加ここまで ---


                        let currentPp = pp;
                        let playedThisTurnInstances = new Set(); // Stores references to card objects played this turn

                        while (true) {
                            // Modified filter to include isPlayable check
                            let playableCards = hand.filter(card => card.cost <= currentPp && !playedThisTurnInstances.has(card) && card.isPlayable !== false);
                            
                            // ネメシスのAFコピー能力の適用
                            if (isNemesisClassSelected) {
                                const afCopyCardsInHand = hand.filter(card => 
                                    card.classFeatures && card.classFeatures.some(f => f.type === 'nemesisAFCopy')
                                );

                                for (const afCopyCard of afCopyCardsInHand) {
                                    const copyCount = afCopyCard.classFeatures.find(f => f.type === 'nemesisAFCopy').copyCount;
                                    const targetArtifacts = hand.filter(c => c.isArtifact && c.type === 'フォロワー' && (c.name === NEMESIS_GENERATED_ARTIFACTS.ATTACK_ARTIFACT.name || c.name === NEMESIS_GENERATED_ARTIFACTS.CASTLE_ARTIFACT.name || c.name.includes('デストロイアーティファクト')));
                                    
                                    if (targetArtifacts.length >= copyCount) {
                                        // コピー可能な枚数分、AFフォロワーを生成
                                        for (let i = 0; i < copyCount; i++) {
                                            if (hand.length < handLimit) {
                                                const copiedCard = { ...targetArtifacts[i], isToken: true };
                                                hand.push(copiedCard);
                                            } else {
                                                break;
                                            }
                                        }
                                        // AFコピーカードは使用済みとして扱う
                                        playedThisTurnInstances.add(afCopyCard);
                                        // 手札からコピー対象のカードを消費
                                        // 複数のAFフォロワーをコピーする場合、最初に発見されたコピー枚数分を消費
                                        for (let i = 0; i < copyCount; i++) {
                                            const index = hand.indexOf(targetArtifacts[i]);
                                            if (index > -1) {
                                                hand.splice(index, 1);
                                            }
                                        }
                                    }
                                }
                                
                                // AFコピー能力使用後の手札で再度プレイ可能なカードをフィルタリング
                                playableCards = hand.filter(card => card.cost <= currentPp && !playedThisTurnInstances.has(card) && card.isPlayable !== false);
                            }

                            if (playableCards.length === 0) {
                                break;
                            }

                            playableCards.sort((a, b) => {
                                // Tokens do not have playPriorityTurns or drawCount, so they will fall to lower priority
                                const isAPriorityPlayCard = a.playPriorityTurns && a.playPriorityTurns.includes(turn) && a.cost <= currentPp;
                                const isBPriorityPlayCard = b.playPriorityTurns && b.playPriorityTurns.includes(turn) && b.cost <= currentPp;

                                if (isAPriorityPlayCard && !isBPriorityPlayCard) return -1;
                                if (!isAPriorityPlayCard && isBPriorityPlayCard) return 1;

                                if (b.cost !== a.cost) {
                                    return b.cost - a.cost;
                                }
                                if (b.drawCount > 0 && a.drawCount === 0) return -1;
                                if (a.drawCount > 0 && b.drawCount === 0) return 1;
                                return 0;
                            });

                            const cardToPlay = playableCards[0];

                            currentPp -= cardToPlay.cost;

                            // Apply class features effects
                            if (cardToPlay.classFeatures) {
                                cardToPlay.classFeatures.forEach(feature => {
                                    if (feature.type === 'witchSpellboost' && isWitchClassSelected) {
                                        currentTurnSpellsPlayed += feature.amount;
                                    } else if (feature.type === 'elfTokenGeneration' && isElfClassSelected && feature.generates) {
                                        if (feature.atEndOfTurn) {
                                            // This is for Titania's specific effect, which is handled separately at end of turn.
                                            // The generic elfTokenGeneration feature (from UI) does not have atEndOfTurn.
                                            // So, this branch will only be true for Titania.
                                            // We just mark that Titania has been played. Actual token generation is below.
                                        } else {
                                            // Immediate token generation for generic elfTokenGeneration feature
                                            for (let i = 0; i < feature.count; i++) {
                                                if (hand.length < handLimit) {
                                                    hand.push({ cost: feature.cost, isToken: true, isPlayable: true }); // Tokens are generally playable
                                                } else {
                                                    break;
                                                }
                                            }
                                        }
                                    } else if (feature.type === 'nemesisArtifactGeneration' && isNemesisClassSelected) {
                                        if (feature.generatesFutureCore) {
                                            for (let i = 0; i < feature.futureCoreCount; i++) {
                                                if (hand.length < handLimit) {
                                                    hand.push({ ...NEMESIS_GENERATED_ARTIFACTS.FUTURE_CORE });
                                                }
                                            }
                                        }
                                        if (feature.generatesPastCore) {
                                            for (let i = 0; i < feature.pastCoreCount; i++) {
                                                if (hand.length < handLimit) {
                                                    hand.push({ ...NEMESIS_GENERATED_ARTIFACTS.PAST_CORE });
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                            
                            // ナイトメアの「モード」能力の処理
                            if (isNightmareClassSelected) {
                                const hasModeAbility = cardTypes.find(ct => ct.id === cardToPlay.id)?.classFeatures?.some(f => f.type === 'nightmareFaithValue');
                                if (hasModeAbility) {
                                    const modeFeature = cardTypes.find(ct => ct.id === cardToPlay.id)?.classFeatures?.find(f => f.type === 'nightmareFaithValue');
                                    faithValueInSim += modeFeature.amount;
                                }
                            }

                            if (isWitchClassSelected && cardToPlay.type === 'スペル') {
                                currentTurnSpellsPlayed++;
                            }
                            
                            if (isElfClassSelected) { // エルフ用: プレイ枚数をカウント
                                currentTurnCardsPlayed++;
                                if (cardToPlay.name === SPECIAL_CARD_NAMES.HOLY_TREE_STAFF.name) { // 聖樹の杖がプレイされたことを記録
                                    holyTreeStaffPlayedThisSim = true;
                                }
                                // 翅の女王・ティターニアがプレイされたことを記録
                                if (cardToPlay.name === SPECIAL_CARD_NAMES.TITANIA.name) {
                                    titaniaEffectActiveThisGame = true;
                                }
                            }

                            const indexInHand = hand.indexOf(cardToPlay);
                            if (indexInHand > -1) {
                                hand.splice(indexInHand, 1);
                            }
                            playedThisTurnInstances.add(cardToPlay);

                            for (let k = 0; k < cardToPlay.drawCount; k++) {
                                drawCardAndUpdateCumulative();
                            }
                        }

                        // 聖樹の杖の効果処理 (ターン終了時)
                        if (isElfClassSelected && holyTreeStaffPlayedThisSim && currentTurnCardsPlayed >= 3) {
                            drawCardAndUpdateCumulative(); // 追加で1枚ドロー
                        }

                        // 翅の女王・ティターニアの効果処理 (ターン終了時)
                        if (isElfClassSelected && titaniaEffectActiveThisGame) {
                            // 1コストフォロワーを手札に1枚加える (重複しない = 毎ターン1回)
                            if (hand.length < handLimit) {
                                hand.push({ cost: 1, isToken: true, name: '1コストフォロワー', isPlayable: true }); // Tokens are generally playable
                            }
                        }


                        // 各ターン終了時での組み合わせ/単一カードチェック
                        if (calculationMode === CALC_MODE_COMBINATION) {
                            combinationSets.filter(set => set.isActive).forEach(set => {
                                // 各ターンで条件が満たされているかを直接カウント
                                if (checkCombinationCondition(cardsDrawnCumulatively, set.conditions)) {
                                    simulationCounts[set.id][turn]++;
                                }
                            });
                        } else { // CALC_MODE_SINGLE
                            // 各ターン終了時の対象カード枚数を記録
                            simulationCounts[turn][totalTargetCardsDrawn]++;
                        }
                        
                        if (isWitchClassSelected) {
                            spellsPlayedPerTurnInSim[turn] = currentTurnSpellsPlayed;
                            cumulativeSpellsPlayedInSim[turn] = cumulativeSpellsPlayedInSim[turn - 1] + currentTurnSpellsPlayed;
                        }
                        if (isElfClassSelected) { // エルフ用: ターンごとのプレイ枚数平均を記録
                            cardsPlayedPerTurnInSim[turn] = currentTurnCardsPlayed;
                        }
                        if (isNightmareClassSelected) { // ナイトメア用: ターンごとの信仰値合計を累積
                            totalFaithValueRawSum[turn] += faithValueInSim;
                        }
                    } // End of turn loop

                    // Accumulate spellboost data from this simulation to the total sums
                    if (isWitchClassSelected) {
                        for (let turn = 0; turn <= maxTurns; turn++) {
                            totalSpellsPlayedPerTurnRawSum[turn] += spellsPlayedPerTurnInSim[turn];
                            totalCumulativeSpellsPlayedRawSum[turn] += cumulativeSpellsPlayedInSim[turn];
                        }
                    }
                    if (isElfClassSelected) { // エルフ用: ターンごとのプレイ枚数合計を累積
                        for (let turn = 0; turn <= maxTurns; turn++) {
                            totalCardsPlayedPerTurnRawSum[turn] += cardsPlayedPerTurnInSim[turn];
                        }
                    }
                }; // End of performSingleSimulationCorrectedSpellboost

                const runBatch = () => {
                    const batchSize = Math.max(1, Math.floor(numSimulations / 100));
                    let currentBatchCount = 0;

                    while (currentBatchCount < batchSize && simulationsCompleted < numSimulations) {
                        performSingleSimulationCorrectedSpellboost();
                        simulationsCompleted++;
                        currentBatchCount++;
                    }

                    if (simulationsCompleted < numSimulations) {
                        requestAnimationFrame(runBatch);
                    } else {
                        const finalResults = [];
                        const activeCombinationSets = combinationSets.filter(set => set.isActive);

                        for (let turn = 0; turn <= maxTurns; turn++) {
                            const currentTurnData = { turn: turn === 0 ? '初期手札+マリガン' : `${turn}ターン目` };
                            
                            if (calculationMode === CALC_MODE_SINGLE) {
                                const displayMaxCopies = Math.min(maxTargetCopiesInDeck, 3);
                                for (let n = 1; n <= displayMaxCopies; n++) {
                                    let countForAtLeastN = 0;
                                    for (let c = n; c <= maxTargetCopiesInDeck; c++) {
                                        countForAtLeastN += simulationCounts[turn][c];
                                    }
                                    currentTurnData[`probabilityAtLeast${n}`] = (countForAtLeastN / numSimulations * 100).toFixed(2);
                                }
                            } else { // CALC_MODE_COMBINATION
                                // 組み合わせモードでは、各ターンの条件達成数を直接表示
                                let totalCombinationProbabilities = 0;
                                activeCombinationSets.forEach(set => {
                                    const prob = (simulationCounts[set.id][turn] / numSimulations * 100);
                                    currentTurnData[`probability_${set.id}`] = prob.toFixed(2);
                                    totalCombinationProbabilities += prob;
                                });

                                // 新しい平均確率の計算と追加
                                if (activeCombinationSets.length > 0) {
                                    currentTurnData.averageCombinationProbability = (totalCombinationProbabilities / activeCombinationSets.length).toFixed(2);
                                } else {
                                    currentTurnData.averageCombinationProbability = '0.00';
                                }
                            }

                            if (isWitchClassSelected) {
                                currentTurnData.averageSpellsPerTurn = (totalSpellsPlayedPerTurnRawSum[turn] / numSimulations).toFixed(2);
                                currentTurnData.averageCumulativeSpells = (totalCumulativeSpellsPlayedRawSum[turn] / numSimulations).toFixed(2);
                            }
                            if (isElfClassSelected) { // エルフ用: ターンごとのプレイ枚数平均を追加
                                currentTurnData.averageCardsPlayedPerTurn = (totalCardsPlayedPerTurnRawSum[turn] / numSimulations).toFixed(2);
                            }
                            if (isNightmareClassSelected) { // ナイトメア用: ターンごとの信仰値平均を追加
                                currentTurnData.averageFaithValue = (totalFaithValueRawSum[turn] / numSimulations).toFixed(2);
                            }
                            finalResults.push(currentTurnData);
                        }

                        setResults(finalResults);
                        setLoading(false);
                    }
                };

                requestAnimationFrame(runBatch);
            }, [cardTypes, calculationMode, selectedTargetCardTypeId, combinationSets, isFirstPlayer, numSimulations, deckSize, maxTurns, extraPpTurn1, extraPpTurn2, selectedClass, destroyArtifactFusions, handLimit]);

            // Helper function to get color class based on probability
            const getProbabilityColorClass = (probability) => {
                const prob = parseFloat(probability);
                if (isNaN(prob)) return '';
                if (prob < 30) {
                    return 'text-red-400';
                } else if (prob >= 30 && prob < 70) {
                    return 'text-yellow-300';
                } else {
                    return 'text-green-400';
                }
            };

            // Helper function to get text color for card type
            const getCardTypeTextColorClass = (type) => {
                switch (type) {
                    case 'フォロワー':
                        return 'text-red-500';
                    case 'スペル':
                        return 'text-purple-500';
                    case 'アミュレット':
                        return 'text-green-500';
                    default:
                        return 'text-gray-200';
                }
            };

            // 計算モード表示用のヘルパー関数
            const getCalculationModeDisplayName = (mode) => {
                switch (mode) {
                    case CALC_MODE_SINGLE:
                        return '単一カードの枚数別確率';
                    case CALC_MODE_COMBINATION:
                        return '複数カードの組み合わせ確率';
                    default:
                        return '不明なモード';
                }
            };

            // --- Local Save/Load/Delete Operations (Simulation Results) ---
            const saveCurrentResultsLocally = () => {
                if (results.length === 0) {
                    setMessage("保存する計算結果がありません。先に計算を実行してください。");
                    return;
                }

                const newSavedItem = {
                    id: Date.now(),
                    description: saveDescription || `無題の計算結果 ${new Date().toLocaleString()}`,
                    timestamp: Date.now(), // Corrected from Date.24
                    resultsData: results,
                    cardTypesData: cardTypes,
                    gameSettingsData: {
                        isFirstPlayer,
                        extraPpTurn1,
                        extraPpTurn2,
                        selectedClass,
                        destroyArtifactFusions, // 保存対象に追加
                    },
                    calculationMode: calculationMode, // 計算モードも保存
                    selectedTargetCardTypeId: selectedTargetCardTypeId, // 単一カードモード用
                    combinationSetsData: combinationSets // 組み合わせモード用
                };

                setSavedSimulations(prevSavedSimulations => {
                    let updatedSimulations = [newSavedItem, ...prevSavedSimulations];
                    if (updatedSimulations.length > maxSavedResults) {
                        updatedSimulations = updatedSimulations.slice(0, maxSavedResults);
                    }
                    setMessage("計算結果が保存されました！");
                    setSaveDescription('');
                    return updatedSimulations;
                });
            };

            const loadSavedResultForComparison = (savedItem) => {
                setComparisonSavedItem(savedItem); // 保存されたアイテム全体をセット
                setMessage(`「${savedItem.description}」を比較対象として読み込みました。`);
                setShowSavedResultsPanel(false);
            };

            const applySavedSettings = (savedItem) => {
                setLoading(true);
                try {
                    // Apply cardTypes with backward compatibility
                    setCardTypes(savedItem.cardTypesData.map(card => {
                        if (card.spellboostIncreaseAmount !== undefined || card.generatesToken !== undefined) {
                            const newFeatures = card.classFeatures || [];
                            if (card.spellboostIncreaseAmount !== undefined) {
                                newFeatures.push({ type: 'witchSpellboost', amount: card.spellboostIncreaseAmount });
                            }
                            if (card.generatesToken !== undefined) {
                                newFeatures.push({ type: 'elfTokenGeneration', generates: card.generatesToken, cost: card.tokenCost, count: card.tokenCount, atEndOfTurn: card.generatesTokenAtEndOfTurn || false });
                            }
                            const { spellboostIncreaseAmount, generatesToken, tokenCost, tokenCount, generatesTokenAtEndOfTurn, ...rest } = card;
                            return { ...rest, classFeatures: newFeatures };
                        }
                        return { ...card, classFeatures: card.classFeatures || [] };
                    }));

                    setIsFirstPlayer(savedItem.gameSettingsData.isFirstPlayer);
                    setExtraPpTurn1(savedItem.gameSettingsData.extraPp1);
                    setExtraPpTurn2(savedItem.gameSettingsData.extraPp2); 
                    setSelectedClass(savedItem.gameSettingsData.selectedClass);
                    setDestroyArtifactFusions(savedItem.gameSettingsData.destroyArtifactFusions || { 1: 'beta', 2: 'beta', 3: 'beta'}); // 新しい設定をロード
                    setCalculationMode(savedItem.calculationMode || CALC_MODE_COMBINATION); // モードもロード
                    setSelectedTargetCardTypeId(savedItem.selectedTargetCardTypeId || (savedItem.cardTypesData[0]?.id || null)); // 単一カード用
                    
                    // 組み合わせデータが存在しない場合（古い保存データなど）のフォールバックと、matchType, matchLocationのデフォルト設定
                    setCombinationSets(
                        savedItem.combinationSetsData?.map(set => ({
                            ...set,
                            isActive: set.isActive !== undefined ? set.isActive : true, // isActiveがなければデフォルトでtrue
                            conditions: set.conditions?.map(cond => ({
                                ...cond,
                                matchType: cond.matchType || MATCH_TYPE_AT_LEAST,
                                matchLocation: cond.matchLocation || MATCH_LOCATION_HAND
                            })) || [{ id: Date.now(), cardTypeId: savedItem.cardTypesData[0]?.id || null, targetCount: 1, matchType: MATCH_TYPE_AT_LEAST, matchLocation: MATCH_LOCATION_HAND }]
                        })) || [{ id: Date.now(), name: '組み合わせ1', isActive: true, conditions: [{ id: Date.now() + 1, cardTypeId: savedItem.cardTypesData[0]?.id || null, targetCount: 1, matchType: MATCH_TYPE_AT_LEAST, matchLocation: MATCH_LOCATION_HAND }] }]
                    );

                    setMessage(`「${savedItem.description}」の設定を適用しました。`);
                    setShowSavedResultsPanel(false);
                } catch (e) {
                    console.error("Error applying saved settings:", e);
                    setMessage("保存済み設定の適用中にエラーが発生しました。");
                } finally {
                    setLoading(false);
                }
            };

            const deleteSavedResultLocally = (id, description) => {
                setSavedSimulations(prevSavedSimulations => {
                    const updatedSimulations = prevSavedSimulations.filter(item => item.id !== id);
                    // 削除されたアイテムが比較対象だった場合、比較対象をクリアする
                    if (comparisonSavedItem && comparisonSavedItem.id === id) {
                        setComparisonSavedItem(null);
                    }
                    setMessage(`「${description}」を削除しました。`);
                    return updatedSimulations;
                });
            };

            // --- New Deck Management Functions ---
            const saveCurrentDeck = () => {
                if (!currentDeckSaveName.trim()) {
                    setMessage("デッキ名を指定してください。");
                    return;
                }
                if (totalCurrentDeckCount !== deckSize) {
                    setMessage(`デッキの合計枚数が${deckSize}枚ではありません。現在: ${totalCurrentDeckCount}枚。保存前に調整してください。`);
                    return;
                }

                const newDeck = {
                    id: Date.now(),
                    name: currentDeckSaveName,
                    cardTypes: cardTypes,
                    timestamp: Date.now(),
                };

                setSavedDecks(prevSavedDecks => {
                    let updatedDecks = [newDeck, ...prevSavedDecks];
                    if (updatedDecks.length > maxSavedDecks) {
                        updatedDecks = updatedDecks.slice(0, maxSavedDecks);
                    }
                    setMessage(`デッキ「${currentDeckSaveName}」を保存しました！`);
                    setCurrentDeckSaveName('');
                    return updatedDecks;
                });
            };

            const loadSavedDeck = (deckToLoad) => {
                setLoading(true);
                try {
                    // Load cardTypes with backward compatibility
                    setCardTypes(deckToLoad.cardTypes.map(card => {
                        if (card.spellboostIncreaseAmount !== undefined || card.generatesToken !== undefined) {
                            const newFeatures = card.classFeatures || [];
                            if (card.spellboostIncreaseAmount !== undefined) {
                                newFeatures.push({ type: 'witchSpellboost', amount: card.spellboostIncreaseAmount });
                            }
                            if (card.generatesToken !== undefined) {
                                newFeatures.push({ type: 'elfTokenGeneration', generates: card.generatesToken, cost: card.tokenCost, count: card.tokenCount, atEndOfTurn: card.generatesTokenAtEndOfTurn || false });
                            }
                            const { spellboostIncreaseAmount, generatesToken, tokenCost, tokenCount, generatesTokenAtEndOfTurn, ...rest } = card;
                            return { ...rest, classFeatures: newFeatures };
                        }
                        return { ...card, classFeatures: card.classFeatures || [] };
                    }));
                    // Reset calculation mode and related settings to default or adapt if needed
                    setCalculationMode(CALC_MODE_COMBINATION); // Default to combination mode
                    setSelectedTargetCardTypeId(deckToLoad.cardTypes[0]?.id || null); // Set to first card of loaded deck
                    setCombinationSets([ // Reset combination sets
                        {
                            id: Date.now(),
                            name: '組み合わせ1',
                            isActive: true,
                            conditions: [
                                { id: Date.now() + 1, cardTypeId: deckToLoad.cardTypes[0]?.id || null, targetCount: 1, matchType: MATCH_TYPE_AT_LEAST, matchLocation: MATCH_LOCATION_HAND }
                            ]
                        }
                    ]);
                    setIsFirstPlayer(true);
                    setExtraPpTurn1(5);
                    setExtraPpTurn2(6);
                    setSelectedClass('');
                    setDestroyArtifactFusions({ 1: 'beta', 2: 'beta', 3: 'beta' });

                    setMessage(`デッキ「${deckToLoad.name}」を読み込みました。`);
                    setShowSavedDecksPanel(false);
                } catch (e) {
                    console.error("Error loading saved deck:", e);
                    setMessage("保存済みデッキの読み込み中にエラーが発生しました。");
                } finally {
                    setLoading(false);
                }
            };

            const deleteSavedDeck = (id, name) => {
                setSavedDecks(prevSavedDecks => {
                    const updatedDecks = prevSavedDecks.filter(deck => deck.id !== id);
                    setMessage(`デッキ「${name}」を削除しました。`);
                    return updatedDecks;
                });
            };

            // Function to add a special card to the deck settings
            const addSpecialCardToDeck = (specialCardData) => {
                setShowDeckSettings(true); // Open deck settings if closed
                setCardTypes(prevCardTypes => {
                    const existingCardIndex = prevCardTypes.findIndex(ct => ct.name === specialCardData.name);
                    let updatedCardTypes;
                    let targetCardId;

                    if (existingCardIndex !== -1) {
                        // Card exists, update its properties
                        updatedCardTypes = prevCardTypes.map((card, index) => {
                            if (index === existingCardIndex) {
                                targetCardId = card.id;
                                return { 
                                    ...card, 
                                    count: specialCardData.defaultCount,
                                    cost: specialCardData.defaultCost,
                                    type: specialCardData.defaultType,
                                    classFeatures: specialCardData.classFeatures ? JSON.parse(JSON.stringify(specialCardData.classFeatures)) : (card.classFeatures || []),
                                };
                            }
                            return card;
                        });
                    } else {
                        // Card does not exist, add it
                        const newCard = {
                            id: Date.now(),
                            name: specialCardData.name,
                            count: specialCardData.defaultCount,
                            cost: specialCardData.defaultCost,
                            drawCount: specialCardData.defaultDrawCount,
                            mulliganKeepCount: specialCardData.defaultMulliganKeepCount,
                            playPriorityTurns: specialCardData.defaultPlayPriorityTurns,
                            type: specialCardData.defaultType,
                            classFeatures: specialCardData.classFeatures ? JSON.parse(JSON.stringify(specialCardData.classFeatures)) : [],
                            isPlayable: true, // Default for non-token cards
                        };
                        updatedCardTypes = [...prevCardTypes, newCard];
                        targetCardId = newCard.id;
                    }

                    // Ensure total deck count doesn't exceed 40 after adding/updating
                    const currentTotal = updatedCardTypes.reduce((sum, ct) => sum + (parseInt(ct.count) || 0), 0);
                    if (currentTotal > deckSize) {
                        setMessage(`デッキの合計枚数が${deckSize}枚を超えました。自動調整は行われません。`);
                    } else {
                        setMessage(`「${specialCardData.name}」がデッキに追加/更新されました。`);
                    }

                    // Scroll to the card after state update
                    // Use a timeout to ensure DOM update before scrolling
                    setTimeout(() => {
                        const node = cardRefs.current.get(targetCardId);
                        if (node) {
                            node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 100); // Small delay to allow DOM to update

                    return updatedCardTypes;
                });
            };

            // --- Export/Import Deck Data Functions ---
            const handleExportDecks = () => {
                if (savedDecks.length === 0) {
                    setMessage("エクスポートするデッキデータがありません。");
                    return;
                }
                try {
                    const dataStr = JSON.stringify(savedDecks, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `shadowverse_decks_export_${new Date().toISOString().slice(0, 10)}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    setMessage("デッキデータをエクスポートしました！");
                } catch (error) {
                    console.error("Error exporting decks:", error);
                    setMessage("デッキのエクスポート中にエラーが発生しました。");
                }
            };

            const handleImportDecks = (event) => {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        // Basic validation: check if it's an array and contains objects with 'id' and 'name'
                        if (Array.isArray(importedData) && importedData.every(item => typeof item === 'object' && item !== null && 'id' in item && 'name' in item && 'cardTypes' in item)) {
                            // Apply backward compatibility for imported decks
                            const processedData = importedData.map(deck => ({
                                ...deck,
                                cardTypes: deck.cardTypes.map(card => {
                                    if (card.spellboostIncreaseAmount !== undefined || card.generatesToken !== undefined) {
                                        const newFeatures = card.classFeatures || [];
                                        if (card.spellboostIncreaseAmount !== undefined) {
                                            newFeatures.push({ type: 'witchSpellboost', amount: card.spellboostIncreaseAmount });
                                        }
                                        if (card.generatesToken !== undefined) {
                                            newFeatures.push({ type: 'elfTokenGeneration', generates: card.generatesToken, cost: card.tokenCost, count: card.tokenCount, atEndOfTurn: card.generatesTokenAtEndOfTurn || false });
                                    }
                                        const { spellboostIncreaseAmount, generatesToken, tokenCost, tokenCount, generatesTokenAtEndOfTurn, ...rest } = card;
                                        return { ...rest, classFeatures: newFeatures };
                                    }
                                    return { ...card, classFeatures: card.classFeatures || [] };
                                })
                            }));
                            setSavedDecks(processedData);
                            setMessage(`デッキデータを${processedData.length}件インポートしました！`);
                        } else {
                            setMessage("不正なファイル形式です。JSON形式のデッキデータファイルを選択してください。");
                        }
                    } catch (error) {
                        console.error("Error importing decks:", error);
                        setMessage("ファイルの読み込みまたは解析中にエラーが発生しました。");
                    }
                };
                reader.readAsText(file);
            };

            const triggerImport = () => {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                fileInput.onchange = handleImportDecks;
                fileInput.click();
            };


            // 単一カードモードの場合の表示枚数
            const selectedTargetCard = cardTypes.find(ct => ct.id === selectedTargetCardTypeId);
            const maxTargetCopiesInDeck = parseInt(selectedTargetCard?.count || 0);
            const displayMaxCopies = Math.min(maxTargetCopiesInDeck, 3);

            const handleDestroyArtifactFusionChange = (fusionNum, value) => {
                setDestroyArtifactFusions(prevFusions => ({
                    ...prevFusions,
                    [fusionNum]: value
                }));
            };

            return (
                <React.Fragment> {/* Added React.Fragment */}
                    <div className="p-4 sm:p-6 md:p-8 bg-gray-900 text-white min-h-screen font-inter">
                        <h1 className="text-3xl sm:text-4xl font-bold text-center mb-6 sm:mb-8 text-purple-400">
                            ひ、引けんの？β版
                        </h1>

                        <div className="max-w-full mx-auto bg-gray-800 rounded-xl shadow-lg p-6 sm:p-8 space-y-6">
                            {/* 計算モード選択 */}
                            <div className="bg-gray-700 rounded-xl shadow-md overflow-hidden p-4 space-y-4">
                                <span className="text-lg font-semibold text-gray-100 block mb-2">計算モード選択</span>
                                <div className="flex flex-col sm:flex-row gap-4">
                                    <label className="inline-flex items-center">
                                        <input
                                            type="radio"
                                            name="calculationMode"
                                            value={CALC_MODE_SINGLE}
                                            checked={calculationMode === CALC_MODE_SINGLE}
                                            onChange={() => setCalculationMode(CALC_MODE_SINGLE)}
                                            className="form-radio text-purple-500 focus:ring-purple-500"
                                        />
                                        <span className="ml-2 text-gray-200">単一カードの枚数別確率</span>
                                    </label>
                                    <label className="inline-flex items-center">
                                        <input
                                            type="radio"
                                            name="calculationMode"
                                            value={CALC_MODE_COMBINATION}
                                            checked={calculationMode === CALC_MODE_COMBINATION}
                                            onChange={() => setCalculationMode(CALC_MODE_COMBINATION)}
                                            className="form-radio text-purple-500 focus:ring-purple-500"
                                        />
                                        <span className="ml-2 text-gray-200">複数カードの組み合わせ確率</span>
                                    </label>
                                </div>
                            </div>

                            {/* Game Settings Section */}
                            <div className="bg-gray-700 rounded-xl shadow-md overflow-hidden">
                                <button
                                    className="w-full flex justify-between items-center p-4 text-lg font-semibold text-gray-100 hover:bg-gray-600 transition duration-200"
                                    onClick={() => setShowGameSettings(!showGameSettings)}
                                >
                                    <span>ゲーム設定</span>
                                    <svg
                                        className={`w-5 h-5 transition-transform duration-200 ${
                                            showGameSettings ? 'rotate-180' : ''
                                        }`}
                                        fill="currentColor"
                                        viewBox="0 0 20 20"
                                        xmlns="http://www.w3.org/2000/svg"
                                    >
                                        <path
                                            fillRule="evenodd"
                                            d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                            clipRule="evenodd"
                                        ></path>
                                    </svg>
                                </button>
                                <div className={`p-4 border-t border-gray-600 space-y-4 accordion-content ${showGameSettings ? 'open' : ''}`}>
                                    {/* Class Selection */}
                                    <div className="flex flex-col">
                                        <label htmlFor="classSelect" className="text-sm font-medium text-gray-300 mb-1">クラス選択</label>
                                        <select
                                            id="classSelect"
                                            value={selectedClass}
                                            onChange={(e) => setSelectedClass(e.target.value)}
                                            className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500"
                                        >
                                            <option value="">設定なし</option>
                                            <option value="Elf">エルフ</option>
                                            <option value="Royal">ロイヤル</option>
                                            <option value="Witch">ウィッチ</option>
                                            <option value="Dragon">ドラゴン</option>
                                            <option value="Nightmare">ナイトメア</option>
                                            <option value="Bishop">ビショップ</option>
                                            <option value="Nemesis">ネメシス</option>
                                        </select>
                                    </div>

                                    {/* Initial Destroy Artifact Selection (only for Nemesis) */}
                                    {selectedClass === 'Nemesis' && (
                                        <div className="flex flex-col mt-4 p-4 bg-gray-800 rounded-md space-y-3">
                                            <p className="text-sm font-medium text-gray-300 mb-1">融合で生成するデストロイアーティファクト:</p>
                                            {[1, 2, 3].map(fusionNum => (
                                                <div key={fusionNum} className="flex items-center gap-2">
                                                    <label htmlFor={`fusion-${fusionNum}-select`} className="text-xs text-gray-400 w-16">
                                                        {fusionNum}回目:
                                                    </label>
                                                    <select
                                                        id={`fusion-${fusionNum}-select`}
                                                        value={destroyArtifactFusions[fusionNum] || 'beta'} // デフォルト値を設定
                                                        onChange={(e) => handleDestroyArtifactFusionChange(fusionNum, e.target.value)}
                                                        className="flex-1 p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                                    >
                                                        {DESTROY_ARTIFACT_OPTIONS.map(option => (
                                                            <option key={option.value} value={option.value}>
                                                                {option.name}
                                                            </option>
                                                        ))}
                                                    </select>
                                                </div>
                                            ))}
                                            <p className="text-xs text-gray-500 mt-2">
                                                ※未設定の融合は自動的にデストロイアーティファクトβになります。
                                            </p>
                                        </div>
                                    )}

                                    {/* Player turn selection */}
                                    <div className="flex flex-col">
                                        <span className="text-sm font-medium text-gray-300 mb-2">プレイヤーのターン</span>
                                        <div className="flex space-x-4">
                                            <label className="inline-flex items-center">
                                                <input
                                                    type="radio"
                                                    name="playerTurn"
                                                    value="first"
                                                    checked={isFirstPlayer}
                                                    onChange={() => setIsFirstPlayer(true)}
                                                    className="form-radio text-purple-500 focus:ring-purple-500"
                                                />
                                                <span className="ml-2 text-gray-200">先攻</span>
                                            </label>
                                            <label className="inline-flex items-center">
                                                <input
                                                    type="radio"
                                                    name="playerTurn"
                                                    value="second"
                                                    checked={!isFirstPlayer}
                                                    onChange={() => setIsFirstPlayer(false)}
                                                    className="form-radio text-purple-500 focus:ring-purple-500"
                                                />
                                                <span className="ml-2 text-gray-200">後攻</span>
                                            </label>
                                        </div>
                                    </div>

                                    {/* Extra PP Turn Settings (only visible for second player) */}
                                    {!isFirstPlayer && (
                                        <div className="flex flex-col sm:flex-row gap-4 mt-4 p-4 bg-gray-800 rounded-md">
                                            <div className="flex flex-col flex-1">
                                                <label htmlFor="extraPpTurn1" className="text-sm font-medium text-gray-300 mb-1">エクストラPP使用ターン1</label>
                                                <input
                                                    type="number"
                                                    id="extraPpTurn1"
                                                    value={extraPpTurn1}
                                                    onChange={(e) => setExtraPpTurn1(e.target.value)}
                                                    className="p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                                    min="1"
                                                    max="5"
                                                />
                                            </div>
                                            <div className="flex flex-col flex-1">
                                                <label htmlFor="extraPpTurn2" className="text-sm font-medium text-gray-300 mb-1">エクストラPP使用ターン2</label>
                                                <input
                                                    type="number"
                                                    id="extraPpTurn2"
                                                    value={extraPpTurn2}
                                                    onChange={(e) => setExtraPpTurn2(e.target.value)}
                                                    className="p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                                    min="6"
                                                    max={maxTurns}
                                                />
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* Deck Card Settings Section */}
                            <div className="bg-gray-700 rounded-xl shadow-md overflow-hidden">
                                <button
                                    className="w-full flex justify-between items-center p-4 text-lg font-semibold text-gray-100 hover:bg-gray-600 transition duration-200"
                                    onClick={() => setShowDeckSettings(!showDeckSettings)}
                                >
                                    <span>デッキカード設定 (現在の合計: {totalCurrentDeckCount} / {deckSize}枚)</span>
                                    <svg
                                        className={`w-5 h-5 transition-transform duration-200 ${
                                            showDeckSettings ? 'rotate-180' : ''
                                        }`}
                                        fill="currentColor"
                                        viewBox="0 0 20 20"
                                        xmlns="http://www.w3.org/2000/svg"
                                    >
                                        <path
                                            fillRule="evenodd"
                                            d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                            clipRule="evenodd"
                                        ></path>
                                    </svg>
                                </button>
                                <div className={`p-4 border-t border-gray-600 accordion-content ${showDeckSettings ? 'open' : ''}`}>
                                    <p className="text-gray-400 text-sm mb-4">各カードの「↑」または「↓」ボタンで並び替えができます。</p>
                                    {cardTypes.map((cardType, index) => (
                                        <div
                                            key={cardType.id}
                                            ref={node => setCardRef(node, cardType.id)} // Add this ref
                                            className={`grid grid-cols-1 sm:grid-cols-8 gap-3 mb-4 p-4 bg-gray-800 rounded-md items-center`}
                                        >
                                            <div className="flex flex-col col-span-2 p-2 bg-gray-700 rounded-md">
                                                <label htmlFor={`cardTypeName-${cardType.id}`} className="text-xs font-semibold text-gray-300 mb-1">カード名</label>
                                                <input
                                                    type="text"
                                                    id={`cardTypeName-${cardType.id}`}
                                                    value={cardType.name}
                                                    onChange={(e) => updateCardType(cardType.id, 'name', e.target.value)}
                                                    className={`p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm ${Object.values(SPECIAL_CARD_NAMES).some(sc => sc.name === cardType.name) ? 'text-yellow-300' : ''}`}
                                                />
                                            </div>
                                            <div className="flex flex-col p-2 bg-gray-700 rounded-md">
                                                <label htmlFor={`cardTypeCount-${cardType.id}`} className="text-xs font-semibold text-gray-300 mb-1">採用枚数</label>
                                                <input
                                                    type="number"
                                                    id={`cardTypeCount-${cardType.id}`}
                                                    value={cardType.count}
                                                    onChange={(e) => updateCardType(cardType.id, 'count', parseInt(e.target.value))}
                                                    className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                                    min="0"
                                                    max="40" // Deck size limit
                                                />
                                            </div>
                                            <div className="flex flex-col p-2 bg-gray-700 rounded-md">
                                                <label htmlFor={`cardTypeCost-${cardType.id}`} className="text-xs font-semibold text-gray-300 mb-1">コスト</label>
                                                <input
                                                    type="number"
                                                    id={`cardTypeCost-${cardType.id}`}
                                                    value={cardType.cost}
                                                    onChange={(e) => updateCardType(cardType.id, 'cost', parseInt(e.target.value))}
                                                    className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                                    min="0"
                                                />
                                            </div>
                                            <div className="flex flex-col p-2 bg-gray-700 rounded-md">
                                                <label htmlFor={`cardTypeDrawCount-${cardType.id}`} className="text-xs font-semibold text-gray-300 mb-1">ドロー枚数</label>
                                                <input
                                                    type="number"
                                                    id={`cardTypeDrawCount-${cardType.id}`}
                                                    value={cardType.drawCount}
                                                    onChange={(e) => updateCardType(cardType.id, 'drawCount', parseInt(e.target.value))}
                                                    className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                                    min="0" // 0 if no draw
                                                />
                                            </div>
                                            {/* マリガンキープ枚数の入力欄 */}
                                            <div className="flex flex-col p-2 bg-gray-700 rounded-md">
                                                <label htmlFor={`cardTypeMulliganKeepCount-${cardType.id}`} className="text-xs font-semibold text-gray-300 mb-1">マリガンキープ枚数</label>
                                                <input
                                                    type="number"
                                                    id={`cardTypeMulliganKeepCount-${cardType.id}`}
                                                    value={cardType.mulliganKeepCount}
                                                    onChange={(e) => updateCardType(cardType.id, 'mulliganKeepCount', parseInt(e.target.value))}
                                                    className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                                    min="0"
                                                    max="3" // Max 3 copies of a card in deck
                                                />
                                            </div>
                                            {/* プレイ優先ターン (ボタン選択) */}
                                            <div className="flex flex-col col-span-2 p-2 bg-gray-700 rounded-md">
                                                <label className="text-xs font-semibold text-gray-300 mb-1">プレイ優先ターン</label>
                                                <div className="flex flex-wrap gap-1">
                                                    {Array.from({ length: 10 }, (_, i) => i + 1).map(turn => ( // Changed maxTurns to 10
                                                        <button
                                                            key={turn}
                                                            onClick={() => updateCardType(cardType.id, 'playPriorityTurns', turn)}
                                                            className={`px-2 py-1 rounded-md text-xs font-medium transition duration-150
                                                                ${cardType.playPriorityTurns.includes(turn)
                                                                    ? 'bg-purple-600 hover:bg-purple-700 text-white'
                                                                    : 'bg-gray-600 hover:bg-gray-500 text-gray-200'
                                                                }`}
                                                        >
                                                            {turn}
                                                            </button>
                                                    ))}
                                                </div>
                                            </div>
                                            {/* カードタイプ選択と色付き文字 */}
                                            <div className="flex flex-col p-2 bg-gray-700 rounded-md">
                                                <label htmlFor={`cardType-${cardType.id}`} className="text-xs font-semibold text-gray-300 mb-1">カードタイプ</label>
                                                <select
                                                    id={`cardType-${cardType.id}`}
                                                    value={cardType.type}
                                                    onChange={(e) => updateCardType(cardType.id, 'type', e.target.value)}
                                                    className={`p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm flex-grow ${getCardTypeTextColorClass(cardType.type)}`}
                                                >
                                                    <option value="フォロワー" className={getCardTypeTextColorClass('フォロワー')}>フォロワー</option>
                                                    <option value="スペル" className={getCardTypeTextColorClass('スペル')}>スペル</option>
                                                    <option value="アミュレット" className={getCardTypeTextColorClass('アミュレット')}>アミュレット</option>
                                                </select>
                                            </div>
                                            {/* Dynamically rendered class features */}
                                            {cardType.classFeatures && cardType.classFeatures.map(feature => {
                                                const featureDef = CLASS_FEATURES_DEFINITIONS[feature.type];
                                                if (featureDef) {
                                                    return (
                                                        // Pass removeFeatureFromCard function to the render method
                                                        <React.Fragment key={feature.type}>
                                                            {featureDef.render(cardType.id, feature, updateCardType, removeFeatureFromCard)}
                                                        </React.Fragment>
                                                    );
                                                }
                                                return null;
                                            })}
                                            <div className="flex flex-col justify-center space-y-1">
                                                <button
                                                    onClick={() => moveCardTypeUp(cardType.id)}
                                                    disabled={index === 0}
                                                    className="bg-gray-500 hover:bg-gray-400 text-white font-bold py-1 px-2 rounded-md transition duration-200 text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                                                >
                                                    ↑
                                                </button>
                                                <button
                                                    onClick={() => moveCardTypeDown(cardType.id)}
                                                    disabled={index === cardTypes.length - 1}
                                                    className="bg-gray-500 hover:bg-gray-400 text-white font-bold py-1 px-2 rounded-md transition duration-200 text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                                                >
                                                    ↓
                                                </button>
                                                <button
                                                    onClick={() => removeCardType(cardType.id)}
                                                    className="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-2 rounded-md transition duration-200 text-sm"
                                                >
                                                    削除
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                    <button
                                        onClick={addCardType}
                                        className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200 mt-2"
                                    >
                                        カードタイプを追加
                                    </button>
                                </div>
                            </div>

                            {/* Class Feature Management Section */}
                            <div className="bg-gray-700 rounded-xl shadow-md overflow-hidden">
                                <button
                                    className="w-full flex justify-between items-center p-4 text-lg font-semibold text-gray-100 hover:bg-gray-600 transition duration-200"
                                    onClick={() => setShowClassFeatureManagement(!showClassFeatureManagement)}
                                >
                                    <span>クラス特性の項目一覧＆追加</span>
                                    <svg
                                        className={`w-5 h-5 transition-transform duration-200 ${
                                            showClassFeatureManagement ? 'rotate-180' : ''
                                        }`}
                                        fill="currentColor"
                                        viewBox="0 0 20 20"
                                        xmlns="http://www.w3.org/2000/svg"
                                    >
                                        <path
                                            fillRule="evenodd"
                                            d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                            clipRule="evenodd"
                                        ></path>
                                    </svg>
                                </button>
                                <div className={`p-4 border-t border-gray-600 accordion-content ${showClassFeatureManagement ? 'open' : ''}`}>
                                    <p className="text-gray-400 text-sm mb-4">
                                        選択したカードに、クラス固有の特性項目を追加・削除できます。
                                    </p>
                                    <div className="flex flex-col sm:flex-row gap-4 mb-4">
                                        <div className="flex-1">
                                            <label htmlFor="cardForFeatureSelect" className="text-sm font-medium text-gray-300 mb-1">対象カード</label>
                                            <select
                                                id="cardForFeatureSelect"
                                                value={selectedCardForFeature || ''}
                                                onChange={(e) => setSelectedCardForFeature(parseInt(e.target.value))}
                                                className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 w-full text-sm"
                                            >
                                                {cardTypes.length === 0 && <option value="">カードタイプを設定してください</option>}
                                                {cardTypes.map(cardType => (
                                                    <option key={cardType.id} value={cardType.id} className={getCardTypeTextColorClass(cardType.type)}>
                                                        {cardType.name || `カードタイプ ${cardType.id}`}
                                                    </option>
                                                ))}
                                            </select>
                                        </div>
                                        <div className="flex-1">
                                            <label htmlFor="featureSelect" className="text-sm font-medium text-gray-300 mb-1">特性項目</label>
                                            <select
                                                id="featureSelect"
                                                value={selectedClassFeatureType}
                                                onChange={(e) => setSelectedClassFeatureType(e.target.value)}
                                                className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 w-full text-sm"
                                            >
                                                <option value="">
                                                    {selectedClass ? `${CLASS_NAME_MAP[selectedClass] || selectedClass}の特性を選択してください` : 'クラスを選択してください'}
                                                </option>
                                                {Object.entries(CLASS_FEATURES_DEFINITIONS)
                                                    .filter(([type, def]) => !selectedClass || def.class === selectedClass)
                                                    .sort(([, defA], [, defB]) => {
                                                        const indexA = CLASS_DISPLAY_ORDER.indexOf(defA.class);
                                                        const indexB = CLASS_DISPLAY_ORDER.indexOf(defB.class);
                                                        if (indexA === -1 && indexB === -1) return 0;
                                                        if (indexA === -1) return 1;
                                                        if (indexB === -1) return -1;
                                                        return indexA - indexB;
                                                    })
                                                    .map(([type, def]) => (
                                                        <option key={type} value={type}>
                                                            {def.displayName}
                                                        </option>
                                                    ))}
                                            </select>
                                        </div>
                                    </div>
                                    <div className="flex gap-2">
                                        <button
                                            onClick={() => addFeatureToCard(selectedCardForFeature, selectedClassFeatureType)}
                                            className="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-200"
                                            disabled={!selectedCardForFeature || !selectedClassFeatureType || loading}
                                        >
                                            選択したカードに特性を追加
                                        </button>
                                        <button
                                            onClick={() => removeFeatureFromCard(selectedCardForFeature, selectedClassFeatureType)}
                                            className="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition duration-200"
                                            disabled={!selectedCardForFeature || !selectedClassFeatureType || loading}
                                        >
                                            選択したカードから特性を削除
                                        </button>
                                    </div>
                                    {cardTypes.length === 0 && (
                                        <p className="text-red-400 text-center text-sm mt-2">※先に「デッキカード設定」でカードタイプを設定してください。</p>
                                    )}
                                </div>
                            </div>

                            {/* Special Effect Cards Section */}
                            <div className="bg-gray-700 rounded-xl shadow-md overflow-hidden">
                                <button
                                    className="w-full flex justify-between items-center p-4 text-lg font-semibold text-gray-100 hover:bg-gray-600 transition duration-200"
                                    onClick={() => setShowSpecialEffectCards(!showSpecialEffectCards)}
                                >
                                    <span>特殊な効果を持つカード一覧</span>
                                    <svg
                                        className={`w-5 h-5 transition-transform duration-200 ${
                                            showSpecialEffectCards ? 'rotate-180' : ''
                                        }`}
                                        fill="currentColor"
                                        viewBox="0 0 20 20"
                                        xmlns="http://www.w3.org/2000/svg"
                                    >
                                        <path
                                            fillRule="evenodd"
                                            d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                            clipRule="evenodd"
                                        ></path>
                                    </svg>
                                </button>
                                <div className={`p-4 border-t border-gray-600 accordion-content ${showSpecialEffectCards ? 'open' : ''}`}>
                                    <div className="bg-gray-800 p-6 rounded-lg shadow-md text-gray-200 space-y-4">
                                        <p className="text-lg font-semibold text-purple-300">現在シミュレーションに組み込まれている特殊効果カード:</p>
                                        <div className="mt-4 space-y-3">
                                            <h4 className="text-md font-semibold text-gray-300">エルフ</h4>
                                            <ul className="list-disc list-inside space-y-2 pl-4">
                                                <li>
                                                    <strong
                                                        className="text-yellow-300 cursor-pointer hover:underline"
                                                        onClick={() => addSpecialCardToDeck(SPECIAL_CARD_NAMES.HOLY_TREE_STAFF)}
                                                    >
                                                        聖樹の杖: コスト3 | アミュレット
                                                    </strong>
                                                    <p className="text-sm text-gray-300 ml-4">
                                                        このカードがプレイされたゲーム中、ターン終了時に「このターン中にプレイしたカードの枚数」が3枚以上だった場合、カードを1枚ドローします。
                                                    </p>
                                                </li>
                                                <li>
                                                    <strong
                                                        className="text-yellow-300 cursor-pointer hover:underline"
                                                        onClick={() => addSpecialCardToDeck(SPECIAL_CARD_NAMES.TITANIA)}
                                                    >
                                                        翅の女王・ティターニア: コスト4 | フォロワー
                                                    </strong>
                                                    <p className="text-sm text-gray-300 ml-4">
                                                        このカードがプレイされたゲーム中、ターン終了時にコスト1のフォロワーを手札に1枚加えます（手札が上限9枚の時は追加されません）。
                                                    </p>
                                                </li>
                                            </ul>
                                        </div>
                                        <p className="text-sm text-gray-400 mt-6 pt-4 border-t border-gray-700">
                                            ※ここにある効果は実際の効果とは違い、シミュレーションを効率よく行うための効果になります。
                                        </p>
                                    </div>
                                </div>
                            </div>

                            {/* Deck Management Section */}
                            <div className="bg-gray-700 rounded-xl shadow-md overflow-hidden">
                                <button
                                    className="w-full flex justify-between items-center p-4 text-lg font-semibold text-gray-100 hover:bg-gray-600 transition duration-200"
                                    onClick={() => setShowDeckManagement(!showDeckManagement)}
                                >
                                    <span>デッキの保存と管理 ({savedDecks.length} / {maxSavedDecks}件)</span>
                                    <svg
                                        className={`w-5 h-5 transition-transform duration-200 ${
                                            showDeckManagement ? 'rotate-180' : ''
                                        }`}
                                        fill="currentColor"
                                        viewBox="0 0 20 20"
                                        xmlns="http://www.w3.org/2000/svg"
                                    >
                                        <path
                                            fillRule="evenodd"
                                            d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                            clipRule="evenodd"
                                        ></path>
                                    </svg>
                                </button>
                                <div className={`p-4 border-t border-gray-600 accordion-content ${showDeckManagement ? 'open' : ''}`}>
                                    <div className="flex flex-col sm:flex-row gap-2">
                                        <input
                                            type="text"
                                            placeholder="現在のデッキを保存する名前"
                                            value={currentDeckSaveName}
                                            onChange={(e) => setCurrentDeckSaveName(e.target.value)}
                                            className="flex-1 p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                        />
                                        <button
                                            onClick={saveCurrentDeck}
                                            className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-200 whitespace-nowrap"
                                            disabled={loading || !currentDeckSaveName.trim() || savedDecks.length >= maxSavedDecks}
                                        >
                                            現在のデッキを保存
                                        </button>
                                    </div>
                                    <div className="flex flex-col sm:flex-row gap-2 mt-4">
                                        <button
                                            onClick={handleExportDecks}
                                            className="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-md transition duration-200"
                                            disabled={loading || savedDecks.length === 0}
                                        >
                                            デッキデータをエクスポート
                                        </button>
                                        <button
                                            onClick={triggerImport}
                                            className="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-md transition duration-200"
                                            disabled={loading}
                                        >
                                            デッキデータをインポート
                                        </button>
                                    </div>
                                    {savedDecks.length === 0 ? (
                                        <p className="text-gray-400 text-center mt-4">保存されたデッキはありません。</p>
                                    ) : (
                                        <ul className="space-y-3 mt-4">
                                            {savedDecks.map((deck) => (
                                                <li key={deck.id} className="bg-gray-800 p-3 rounded-md shadow-sm flex flex-col sm:flex-row items-center justify-between gap-2">
                                                    <div className="flex-1 text-gray-100 font-semibold truncate">
                                                        {deck.name}
                                                        <span className="block text-xs text-gray-400 font-normal">{new Date(deck.timestamp).toLocaleString()}</span>
                                                    </div>
                                                    <div className="flex flex-wrap gap-2 justify-end">
                                                        <button
                                                            onClick={() => loadSavedDeck(deck)}
                                                            className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-3 rounded-md transition duration-200 text-sm"
                                                            disabled={loading}
                                                        >
                                                            読み込む
                                                        </button>
                                                        <button
                                                            onClick={() => deleteSavedDeck(deck.id, deck.name)}
                                                            className="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-md transition duration-200 text-sm"
                                                            disabled={loading}
                                                        >
                                                            削除
                                                        </button>
                                                    </div>
                                                </li>
                                            ))}
                                        </ul>
                                    )}
                                </div>
                            </div>

                            {/* 確率を計算する対象カードの選択セクション (モードによって表示を切り替え) */}
                            {calculationMode === CALC_MODE_SINGLE && (
                                <div className="bg-gray-700 rounded-xl shadow-md overflow-hidden p-4 space-y-4">
                                    <span className="w-full block text-lg font-semibold text-gray-100">
                                        確率を計算する対象カード
                                    </span>
                                    <div className="flex flex-col">
                                        <label htmlFor="targetCardSelect" className="text-sm font-medium text-gray-300 mb-1">対象カード</label>
                                        <select
                                            id="targetCardSelect"
                                            value={selectedTargetCardTypeId || ''}
                                            onChange={(e) => setSelectedTargetCardTypeId(parseInt(e.target.value))}
                                            className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500"
                                        >
                                            {cardTypes.length === 0 && <option value="">カードタイプを設定してください</option>}
                                            {cardTypes.map(cardType => (
                                                <option key={cardType.id} value={cardType.id} className={getCardTypeTextColorClass(cardType.type)}>
                                                    {cardType.name || `カードタイプ ${cardType.id}`}
                                                </option>
                                            ))}
                                        </select>
                                    </div>
                                </div>
                            )}

                            {calculationMode === CALC_MODE_COMBINATION && (
                                <div className="bg-gray-700 rounded-xl shadow-md overflow-hidden">
                                    <div className="w-full p-4 text-lg font-semibold text-gray-100">
                                        確率を計算する対象カードの組み合わせ
                                    </div>
                                    <div className="p-4 border-t border-gray-600 space-y-4">
                                        {combinationSets.length === 0 && (
                                            <p className="text-gray-400 text-center">対象とするカードの組み合わせセットを追加してください。</p>
                                        )}
                                        {combinationSets.map((comboSet) => (
                                            <div key={comboSet.id} className="bg-gray-800 p-4 rounded-md shadow-sm mb-4">
                                                <div className="flex items-center justify-between mb-3">
                                                    <input
                                                        type="text"
                                                        value={comboSet.name}
                                                        onChange={(e) => updateCombinationSetName(comboSet.id, e.target.value)}
                                                        className="flex-1 p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500 text-sm mr-2"
                                                    />
                                                    <label className="inline-flex items-center cursor-pointer mr-2">
                                                        <input
                                                            type="checkbox"
                                                            className="sr-only peer"
                                                            checked={comboSet.isActive}
                                                            onChange={() => toggleCombinationSetActivity(comboSet.id)}
                                                        />
                                                        <div className="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 dark:peer-focus:ring-purple-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-purple-600"></div>
                                                        <span className="ms-3 text-sm font-medium text-gray-300">{comboSet.isActive ? '有効' : '無効'}</span>
                                                    </label>
                                                    <button
                                                        onClick={() => removeCombinationSet(comboSet.id)}
                                                        className="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-2 rounded-md transition duration-200 text-sm"
                                                    >
                                                        セット削除
                                                    </button>
                                                </div>
                                                {comboSet.conditions.length === 0 && (
                                                    <p className="text-gray-400 text-center text-sm mb-2">この組み合わせセットに条件を追加してください。</p>
                                                )}
                                                {comboSet.conditions.map((cond) => {
                                                    const selectedCardType = cardTypes.find(ct => ct.id === cond.cardTypeId);
                                                    const maxTargetCount = selectedCardType ? selectedCardType.count : 3; // デフォルトは3
                                                    return (
                                                        <div key={cond.id} className="flex flex-col sm:flex-row gap-2 p-3 bg-gray-700 rounded-md items-center mb-2">
                                                            <div className="flex-1 w-full">
                                                                <label htmlFor={`condCardSelect-${cond.id}`} className="sr-only">対象カード</label>
                                                                <select
                                                                    id={`condCardSelect-${cond.id}`}
                                                                    value={cond.cardTypeId || ''}
                                                                    onChange={(e) => updateCombinationCondition(comboSet.id, cond.id, 'cardTypeId', parseInt(e.target.value))}
                                                                    className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 w-full text-sm"
                                                                >
                                                                    {cardTypes.length === 0 && <option value="">カードタイプを設定してください</option>}
                                                                    {cardTypes.map(cardType => (
                                                                        <option key={cardType.id} value={cardType.id} className={getCardTypeTextColorClass(cardType.type)}>
                                                                            {cardType.name || `カードタイプ ${cardType.id}`}
                                                                        </option>
                                                                    ))}
                                                                </select>
                                                            </div>
                                                            <div className="flex-shrink-0 flex items-center gap-2">
                                                                <label htmlFor={`condTargetCount-${cond.id}`} className="sr-only">枚数</label>
                                                                <input
                                                                    type="number"
                                                                    id={`condTargetCount-${cond.id}`}
                                                                    value={cond.targetCount}
                                                                    onChange={(e) => updateCombinationCondition(comboSet.id, cond.id, 'targetCount', parseInt(e.target.value))}
                                                                    className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm w-20 text-center"
                                                                    min="0"
                                                                    max={maxTargetCount}
                                                                />
                                                                <select
                                                                    id={`condMatchType-${cond.id}`}
                                                                    value={cond.matchType}
                                                                    onChange={(e) => updateCombinationCondition(comboSet.id, cond.id, 'matchType', e.target.value)}
                                                                    className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                                                >
                                                                    <option value={MATCH_TYPE_AT_LEAST}>枚以上</option>
                                                                    <option value={MATCH_TYPE_EXACTLY}>枚丁度</option>
                                                                </select>
                                                                <select
                                                                    id={`condMatchLocation-${cond.id}`}
                                                                    value={cond.matchLocation}
                                                                    onChange={(e) => updateCombinationCondition(comboSet.id, cond.id, 'matchLocation', e.target.value)}
                                                                    className="p-2 rounded-md bg-gray-600 border border-gray-500 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                                                >
                                                                    <option value={MATCH_LOCATION_HAND}>手札に来る</option>
                                                                    <option value={MATCH_LOCATION_DECK}>デッキに残す</option>
                                                                </select>
                                                            </div>
                                                            <button
                                                                onClick={() => removeCombinationCondition(comboSet.id, cond.id)}
                                                                className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm flex-shrink-0"
                                                            >
                                                                削除
                                                            </button>
                                                        </div>
                                                    );
                                                })}
                                                <button
                                                    onClick={() => addCombinationCondition(comboSet.id)}
                                                    className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200 mt-2"
                                                    disabled={cardTypes.length === 0}
                                                >
                                                    条件を追加
                                                </button>
                                            </div>
                                        ))}
                                        <button
                                            onClick={addCombinationSet}
                                            className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md transition duration-200 mt-4"
                                        >
                                            新しい組み合わせセットを追加
                                        </button>
                                        {cardTypes.length === 0 && (
                                            <p className="text-red-400 text-center text-sm mt-2">※先に「デッキカード設定」でカードタイプを設定してください。</p>
                                        )}
                                    </div>
                                </div>
                            )}


                            {/* Run simulation button */}
                            <button
                                onClick={runSimulation}
                                className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-md transition duration-200 text-lg shadow-lg"
                                disabled={loading}
                            >
                                {loading ? '計算中...' : '確率を計算'}
                            </button>

                            {/* Results display */}
                            {results.length > 0 && (
                                <div className="mt-8">
                                    <h2 className="text-2xl font-semibold text-purple-300 mb-4 text-center">計算結果</h2>
                                    <p className="text-gray-200 text-center mb-4">
                                        {calculationMode === CALC_MODE_SINGLE
                                            ? `選択したカードを各ターン開始時までに引く累積確率です。`
                                            : `指定したカードの組み合わせが各ターン終了時に条件を満たす確率です。`
                                        }
                                    </p>
                                    <div className="overflow-x-auto rounded-lg shadow-md">
                                        <table className="min-w-full bg-gray-700 text-white rounded-lg">
                                            <thead>
                                                <tr className="bg-gray-600">
                                                    <th className="py-3 px-4 text-left text-sm font-medium text-gray-300 uppercase tracking-wider rounded-tl-lg">ターン</th>
                                                    {calculationMode === CALC_MODE_SINGLE ? (
                                                        <>
                                                            {Array.from({ length: displayMaxCopies }).map((_, i) => (
                                                                <th key={`current-prob-${i}`} className="py-3 px-4 text-left text-sm font-medium text-gray-300 uppercase tracking-wider">
                                                                    今回の結果 ({i + 1}枚以上)
                                                                </th>
                                                            ))}
                                                            {comparisonSavedItem && comparisonSavedItem.calculationMode === CALC_MODE_SINGLE && Array.from({ length: Math.min(parseInt(comparisonSavedItem.cardTypesData.find(ct => ct.id === comparisonSavedItem.selectedTargetCardTypeId)?.count || 0), 3) }).map((_, i) => (
                                                                <th key={`comp-prob-${i}`} className={`py-3 px-4 text-left text-sm font-medium text-gray-300 uppercase tracking-wider`}>
                                                                    比較対象 ({i + 1}枚以上)
                                                                </th>
                                                            ))}
                                                        </>
                                                    ) : (
                                                        <>
                                                            {combinationSets.filter(set => set.isActive).map(set => (
                                                                <th key={`current-prob-${set.id}`} className="py-3 px-4 text-left text-sm font-medium text-gray-300 uppercase tracking-wider">
                                                                    {set.name} (%)
                                                                </th>
                                                            ))}
                                                            {/* 新しい平均確率のヘッダー */}
                                                            {combinationSets.filter(set => set.isActive).length > 1 && (
                                                                <th className="py-3 px-4 text-left text-sm font-medium text-gray-300 uppercase tracking-wider">
                                                                    平均確率 (%)
                                                                </th>
                                                            )}
                                                            {comparisonSavedItem && comparisonSavedItem.calculationMode === CALC_MODE_COMBINATION && (
                                                                <>
                                                                    {comparisonSavedItem.combinationSetsData.filter(set => set.isActive).map(compSet => {
                                                                        const probKey = `probability_${compSet.id}`;
                                                                        const probValue = loadedCompRes && loadedCompRes[probKey] !== undefined ? loadedCompRes[probKey] : '-';
                                                                        return (
                                                                            <td key={`comp-data-${compSet.id}-${index}`} className={`py-3 px-4 whitespace-nowrap text-sm ${getProbabilityColorClass(probValue)}`}>
                                                                                {probValue}
                                                                            </td>
                                                                        );
                                                                    })}
                                                                    {/* 比較対象の平均確率セル */}
                                                                    {comparisonSavedItem.combinationSetsData.filter(set => set.isActive).length > 1 && (
                                                                        <td className={`py-3 px-4 whitespace-nowrap text-sm ${loadedCompRes && loadedCompRes.averageCombinationProbability !== undefined ? getProbabilityColorClass(loadedCompRes.averageCombinationProbability) : ''}`}>
                                                                            {loadedCompRes && loadedCompRes.averageCombinationProbability !== undefined ? loadedCompRes.averageCombinationProbability : '-'}
                                                                        </td>
                                                                    )}
                                                                </>
                                                            )}
                                                        </>
                                                    )}
                                                    {selectedClass === 'Witch' && (
                                                        <>
                                                            <th className="py-3 px-4 text-left text-sm font-medium text-gray-300 uppercase tracking-wider">
                                                                スペルブースト (ターン平均)
                                                            </th>
                                                            <th className="py-3 px-4 text-left text-sm font-medium text-gray-300 uppercase tracking-wider">
                                                                スペルブースト (累計平均)
                                                            </th>
                                                        </>
                                                    )}
                                                    {selectedClass === 'Elf' && ( // エルフ用データ
                                                        <th className="py-3 px-4 whitespace-nowrap text-sm">
                                                            プレイ枚数 (ターン平均)
                                                        </th>
                                                    )}
                                                    {selectedClass === 'Nightmare' && ( // ナイトメア用データ
                                                        <th className="py-3 px-4 text-left text-sm font-medium text-gray-300 uppercase tracking-wider">
                                                            信仰値 (平均)
                                                        </th>
                                                    )}
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {results.map((res, index) => {
                                                    const loadedCompRes = comparisonSavedItem?.resultsData.find(p => p.turn === res.turn);
                                                    return (
                                                        <tr key={index} className={index % 2 === 0 ? 'bg-gray-700' : 'bg-gray-600'}>
                                                            <td className="py-3 px-4 whitespace-nowrap text-sm">{res.turn}</td>
                                                            {calculationMode === CALC_MODE_SINGLE ? (
                                                                <>
                                                                    {Array.from({ length: displayMaxCopies }).map((_, i) => (
                                                                        <td key={`current-data-${index}-${i}`} className={`py-3 px-4 whitespace-nowrap text-sm ${getProbabilityColorClass(res[`probabilityAtLeast${i + 1}`])}`}>
                                                                            {res[`probabilityAtLeast${i + 1}`] !== undefined ? res[`probabilityAtLeast${i + 1}`] : '-'}
                                                                        </td>
                                                                    ))}
                                                                    {comparisonSavedItem && comparisonSavedItem.calculationMode === CALC_MODE_SINGLE && Array.from({ length: Math.min(parseInt(comparisonSavedItem.cardTypesData.find(ct => ct.id === comparisonSavedItem.selectedTargetCardTypeId)?.count || 0), 3) }).map((_, i) => {
                                                                        const probValue = loadedCompRes && loadedCompRes[`probabilityAtLeast${i + 1}`] !== undefined ? loadedCompRes[`probabilityAtLeast${i + 1}`] : '-';
                                                                        return (
                                                                            <td key={`comp-data-${index}-${i}`} className={`py-3 px-4 whitespace-nowrap text-sm ${getProbabilityColorClass(probValue)}`}>
                                                                                {probValue}
                                                                            </td>
                                                                        );
                                                                    })}
                                                                </>
                                                            ) : (
                                                                <>
                                                                    {combinationSets.filter(set => set.isActive).map(set => (
                                                                        <td key={`prob-cell-${set.id}-${index}`} className={`py-3 px-4 whitespace-nowrap text-sm ${getProbabilityColorClass(res[`probability_${set.id}`])}`}>
                                                                            {res[`probability_${set.id}`] !== undefined ? res[`probability_${set.id}`] : '-'}
                                                                        </td>
                                                                    ))}
                                                                    {/* 新しい平均確率のセル */}
                                                                    {combinationSets.filter(set => set.isActive).length > 1 && (
                                                                        <td className={`py-3 px-4 whitespace-nowrap text-sm ${getProbabilityColorClass(res.averageCombinationProbability)}`}>
                                                                            {res.averageCombinationProbability}
                                                                        </td>
                                                                    )}
                                                                    {comparisonSavedItem && comparisonSavedItem.calculationMode === CALC_MODE_COMBINATION && (
                                                                        <>
                                                                            {comparisonSavedItem.combinationSetsData.filter(set => set.isActive).map(compSet => {
                                                                                const probKey = `probability_${compSet.id}`;
                                                                                const probValue = loadedCompRes && loadedCompRes[probKey] !== undefined ? loadedCompRes[probKey] : '-';
                                                                                return (
                                                                                    <td key={`comp-data-${compSet.id}-${index}`} className={`py-3 px-4 whitespace-nowrap text-sm ${getProbabilityColorClass(probValue)}`}>
                                                                                        {probValue}
                                                                                    </td>
                                                                                );
                                                                            })}
                                                                            {/* 比較対象の平均確率セル */}
                                                                            {comparisonSavedItem.combinationSetsData.filter(set => set.isActive).length > 1 && (
                                                                                <td className={`py-3 px-4 whitespace-nowrap text-sm ${loadedCompRes && loadedCompRes.averageCombinationProbability !== undefined ? getProbabilityColorClass(loadedCompRes.averageCombinationProbability) : ''}`}>
                                                                                    {loadedCompRes && loadedCompRes.averageCombinationProbability !== undefined ? loadedCompRes.averageCombinationProbability : '-'}
                                                                                </td>
                                                                            )}
                                                                        </>
                                                                    )}
                                                                </>
                                                            )}
                                                            {selectedClass === 'Witch' && (
                                                                <>
                                                                    <td className="py-3 px-4 whitespace-nowrap text-sm">
                                                                        {res.averageSpellsPerTurn !== undefined ? res.averageSpellsPerTurn : '-'}
                                                                    </td>
                                                                    <td className="py-3 px-4 whitespace-nowrap text-sm">
                                                                        {res.averageCumulativeSpells !== undefined ? res.averageCumulativeSpells : '-'}
                                                                    </td>
                                                                </>
                                                            )}
                                                            {selectedClass === 'Elf' && ( // エルフ用データ
                                                                <td className="py-3 px-4 whitespace-nowrap text-sm">
                                                                    {res.averageCardsPlayedPerTurn !== undefined ? res.averageCardsPlayedPerTurn : '-'}
                                                                </td>
                                                            )}
                                                            {selectedClass === 'Nightmare' && ( // ナイトメア用データ
                                                                <td className="py-3 px-4 whitespace-nowrap text-sm">
                                                                    {res.averageFaithValue !== undefined ? res.averageFaithValue : '-'}
                                                                </td>
                                                            )}
                                                        </tr>
                                                    );
                                                })}
                                            </tbody>
                                        </table>
                                    </div>
                                    {/* Message display for save/load operations */}
                                    {message && (
                                        <div className="bg-green-800 text-green-200 p-3 rounded-md text-center mt-4">
                                            {message}
                                        </div>
                                    )}
                                    {/* Save current results */}
                                    <div className="flex flex-col sm:flex-row gap-2 mt-4">
                                        <input
                                            type="text"
                                            placeholder="保存する結果のメモ (オプション)"
                                            value={saveDescription}
                                            onChange={(e) => setSaveDescription(e.target.value)}
                                            className="flex-1 p-2 rounded-md bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500 text-sm"
                                        />
                                        <button
                                            onClick={saveCurrentResultsLocally}
                                            className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-200 whitespace-nowrap"
                                            disabled={loading || results.length === 0}
                                        >
                                            計算結果を保存 ({savedSimulations.length}/{maxSavedResults})
                                        </button>
                                    </div>
                                    {/* Clear comparison results button */}
                                    {comparisonSavedItem && (
                                        <button
                                            onClick={() => setComparisonSavedItem(null)}
                                            className="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition duration-200 mt-4"
                                        >
                                            比較対象をクリア
                                        </button>
                                    )}
                                </div>
                            )}

                            {/* Saved Results Button (to open slide-in panel) */}
                            <button
                                onClick={() => setShowSavedResultsPanel(true)}
                                className="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-md transition duration-200 mt-6"
                            >
                                保存済み計算結果 ({savedSimulations.length}件)
                            </button>

                            {/* Deck Card Settings Usage Section */}
                            <div className="bg-gray-700 rounded-xl shadow-md overflow-hidden">
                                <button
                                    className="w-full flex justify-between items-center p-4 text-lg font-semibold text-gray-100 hover:bg-gray-600 transition duration-200"
                                    onClick={() => setShowDeckSettingsUsage(!showDeckSettingsUsage)}
                                >
                                    <span>デッキカード設定の使い方</span>
                                    <svg
                                        className={`w-5 h-5 transition-transform duration-200 ${
                                            showDeckSettingsUsage ? 'rotate-180' : ''
                                        }`}
                                        fill="currentColor"
                                        viewBox="0 0 20 20"
                                        xmlns="http://www.w3.org/2000/svg"
                                    >
                                        <path
                                            fillRule="evenodd"
                                            d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                            clipRule="evenodd"
                                        ></path>
                                    </svg>
                                </button>
                                <div className={`p-4 border-t border-gray-600 accordion-content ${showDeckSettingsUsage ? 'open' : ''}`}>
                                    <div className="bg-gray-800 p-6 rounded-lg shadow-md text-gray-200 space-y-4">
                                        <p>「デッキカード設定」では、あなたのデッキに含まれるカードの種類と、それぞれのカードが持つ特性を設定します。</p>
                                        <ul className="list-disc list-inside space-y-3 pl-4">
                                            <li>
                                                <strong>カード名:</strong> カードの名前を入力します。設定を管理しやすくするために設定してください。
                                                特殊な効果を持つカード名を入力すると、その名前が<span className="text-yellow-300">黄色</span>で表示され、効果を反映したシミュレーションが行われます。
                                            </li>
                                            <li>
                                                <strong>採用枚数:</strong> デッキに採用するこのカードの枚数を入力します。デッキの合計枚数が{deckSize}枚になるように調整してください。
                                            </li>
                                            <li>
                                                <strong>コスト:</strong> このカードをプレイするために必要なPP（プレイポイント）を入力します。
                                            </li>
                                            <li>
                                                <strong>ドロー枚数:</strong> このカードをプレイしたときにデッキからドローするカードの枚数を入力します。ドロー効果がない場合は「0」を設定してください。
                                            </li>
                                            <li>
                                                <strong>マリガンキープ枚数:</strong> マリガン時にこのカードを何枚キープするかを設定します。例えば「3」に設定すると、マリガン時にこのカードが手札にあれば最大3枚までキープしようとします。
                                            </li>
                                            <li>
                                                <strong>プレイ優先ターン:</strong><br/>
                                                このカードを特定のターンに優先してプレイしたい場合に、そのターン数をクリックして選択します。選択されたターンは紫色に変わります。再度クリックすると選択が解除されます。何も選択しない場合、そのカードはプレイ優先の対象になりません。設定したターンになると、このカードはドローカードよりも優先して使用されます（PPが足りる場合）。
                                            </li>
                                            <li>
                                                <strong>カードタイプ:</strong><br/>
                                                このカードのタイプを選択します。「フォロワー」は赤、「スペル」は紫、「アミュレット」は緑で表示されます。
                                            </li>
                                            <li>
                                                <strong>クラス特性項目:</strong><br/>
                                                「クラス特性の項目一覧＆追加」セクションでこのカードに追加されたクラス固有の項目が表示されます。例えば、ウィッチクラスを選んだ状態で「追加スペルブースト」が追加されていれば、その項目が表示され、値を設定できます。
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>


                            {/* Calculation method display/hide button */}
                            <div className="bg-gray-700 rounded-xl shadow-md overflow-hidden">
                                <button
                                    className="w-full flex justify-between items-center p-4 text-lg font-semibold text-gray-100 hover:bg-gray-600 transition duration-200"
                                    onClick={() => setShowCalculationMethod(!showCalculationMethod)}
                                >
                                    <span>計算方法を{showCalculationMethod ? '非表示' : '表示'}</span>
                                    <svg
                                        className={`w-5 h-5 transition-transform duration-200 ${
                                            showCalculationMethod ? 'rotate-180' : ''
                                        }`}
                                        fill="currentColor"
                                        viewBox="0 0 20 20"
                                        xmlns="http://www.w3.org/2000/svg"
                                    >
                                        <path
                                            fillRule="evenodd"
                                            d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                            clipRule="evenodd"
                                        ></path>
                                    </svg>
                                </button>
                                <div className={`p-4 border-t border-gray-600 accordion-content ${showCalculationMethod ? 'open' : ''}`}>
                                    <div className="bg-gray-700 p-6 rounded-lg shadow-md text-gray-200 space-y-4">
                                        <h3 className="text-xl font-semibold text-purple-200 mt-6 mb-2">シミュレーションのフロー:</h3>
                                        <p>このツールでのカードを引く確率計算は、以下の流れでシミュレーションを行います。</p>
                                        <ol className="list-decimal list-inside space-y-4 pl-4">
                                            <li>
                                                <strong>デッキの準備とシャッフル</strong>
                                                <ul className="list-disc list-inside ml-4 mt-2 space-y-1">
                                                    <li>あなたが設定したカードの種類と枚数で{deckSize}枚の仮想デッキを作成</li>
                                                    <li>デッキをランダムにシャッフル</li>
                                                </ul>
                                            </li>
                                            <div className="text-center text-purple-300 text-2xl my-2">↓</div>
                                            <li>
                                                <strong>最初の手札とマリガン</strong>
                                                <ul className="list-disc list-inside ml-4 mt-2 space-y-1">
                                                    <li>デッキから4枚のカードを引く</li>
                                                    <li>設定された「マリガンキープ枚数」に基づいてカードをキープ</li>
                                                    <li>キープしなかったカードはデッキに戻し、その枚数分を再ドロー</li>
                                                    {calculationMode === CALC_MODE_SINGLE ? (
                                                        <li>この時点での対象カードの枚数を記録（0ターン目）</li>
                                                    ) : (
                                                        <li>この時点での有効な各組み合わせセットについて、条件を満たしているか記録（0ターン目）</li>
                                                    )}
                                                </ul>
                                            </li>
                                            <div className="text-center text-purple-300 text-2xl my-2">↓</div>
                                            <li>
                                                <strong>ターンごとのゲーム進行 (1～{maxTurns}ターン)</strong>
                                                <ul className="list-disc list-inside ml-4 mt-2 space-y-1">
                                                    <li>
                                                        <strong>ターン開始時:</strong>
                                                        <ul className="list-circle list-inside ml-4 mt-1">
                                                            <li>PP（プレイポイント）が1増える（最大10）</li>
                                                            <li>デッキから1枚カードを引く (手札が{handLimit}枚の場合、引いたカードは破棄)</li>
                                                            <li>後攻の場合、指定ターンで追加PPを使用するか判断（AIが自動で判断）</li>
                                                        </ul>
                                                    </li>
                                                    <li>
                                                        <strong>カードの使用:</strong>
                                                        <ul className="list-circle list-inside ml-4 mt-1">
                                                            <li>手札の中から、現在のPPでプレイ可能なカードを以下の優先順位でプレイ</li>
                                                            <ol className="list-decimal list-inside ml-6 mt-1">
                                                                <li>現在のターンが「プレイ優先ターン」に設定されているカード（複数設定可）</li>
                                                                <li>最もコストの高いカード</li>
                                                                <li>ドロー効果を持つカード</li>
                                                            </ol>
                                                            <li>使用したカードは手札からなくなる</li>
                                                            <li>ドロー効果でカードを引いた場合、手札に加える（手札が{handLimit}枚の場合、引いたカードは破棄）</li>
                                                            <li>
                                                                **クラス特性の適用:**<br/>
                                                                選択されているクラスと、カードに設定されているクラス特性に応じて、以下の効果が適用されます。
                                                                <ul className="list-circle list-inside ml-6 mt-1">
                                                                    <li>**ウィッチ:** 「追加スペルブースト」が設定されたスペルをプレイすると、設定された値分、スペルブースト量が追加されます。</li>
                                                                    <li>**エルフ:** 「トークン生成」が設定されたカードをプレイすると、設定されたコストと枚数のトークンが手札に追加されます（手札上限は考慮）。</li>
                                                                    <li>**ネメシス:** 「AF生成」が設定されたカードがプレイされた場合、設定に応じて「フューチャー・コア」や「パスト・コア」が手札に加わります（手札上限は考慮）。
                                                                        <br/>
                                                                        **※生成されたコアの「融合」による変身は、現時点ではシミュレーションに含まれません。**
                                                                    </li>
                                                                    <li>**聖樹の杖:** カード名が「聖樹の杖」のカードがプレイされたゲーム中、ターン終了時に「このターン中にプレイしたカードの枚数」が3枚以上だった場合、カードを1枚ドローします。</li>
                                                                    <li>**翅の女王・ティターニア:** カード名が「翅の女王・ティターニア」のカードがプレイされたゲーム中、ターン終了時にコスト1のフォロワーを手札に1枚加えます（手札が上限9枚の時は追加されません）。</li>
                                                                </ul>
                                                            </li>
                                                        </ul>
                                                    </li>
                                                    <li>
                                                        <strong>ターン終了時:</strong>
                                                        {calculationMode === CALC_MODE_SINGLE ? (
                                                            <li>そのターンまでに引いた対象カードの合計枚数を記録</li>
                                                        ) : (
                                                            <li>そのターン終了時に有効な各組み合わせセットについて、条件を満たしているか記録</li>
                                                        )}
                                                    </li>
                                                </ul>
                                            </li>
                                            <div className="text-center text-purple-300 text-2xl my-2">↓</div>
                                            <li>
                                                <strong>結果のまとめ:</strong>
                                                <ul className="list-disc list-inside ml-4 mt-2 space-y-1">
                                                    <li>上記1～3のシミュレーションを{numSimulations}回繰り返す</li>
                                                    {calculationMode === CALC_MODE_SINGLE ? (
                                                        <li>各ターン終了時までに、対象カードを「1枚以上」「2枚以上」「3枚以上」引けた回数を集計</li>
                                                    ) : (
                                                        <>
                                                            <li>各ターン終了時において、有効な各組み合わせセットが条件を満たした回数を集計</li>
                                                            <li>すべての有効な組み合わせセットの確率を合計し、その数で割って平均確率を算出</li>
                                                        </>
                                                    )}
                                                    <li>集計した回数を総シミュレーション回数で割り、確率（パーセンテージ）として表示</li>
                                                    {selectedClass === 'Witch' && (
                                                        <>
                                                            <li>ウィッチクラス選択時は、各ターン終了時までにプレイされたスペルの合計数（追加スペルブースト量を含む）の平均値を「スペルブースト (ターン平均)」として、またそれまでの累計スペルブースト数の平均値を「スペルブースト (累計平均)」として表示します。</li>
                                                        </>
                                                    )}
                                                    {selectedClass === 'Elf' && ( // エルフ用結果説明
                                                        <li>エルフクラス選択時は、各ターン終了時までにプレイされたカードの合計枚数の平均値を「プレイ枚数 (ターン平均)」として表示します。これは、エルフの「コンボ」能力を考慮するための指標となります。</li>
                                                    )}
                                                    {selectedClass === 'Nightmare' && ( // ナイトメア用結果説明
                                                        <li>ナイトメアクラス選択時は、各ターン終了時までに増加した信仰値の平均値を「信仰値 (平均)」として表示します。</li>
                                                    )}
                                                </ul>
                                            </li>
                                        </ol>
                                        <p className="text-sm text-gray-400 mt-4">
                                            このシミュレーションは、プレイヤーが常に最高の判断をするわけではなく、設定されたAIのルールに基づいて動きます。そのため、実際のゲームプレイとは少し違う結果になることもありますが、おおよその傾向や確率を知るのに役立ちます。
                                        </p>
                                    </div>
                                </div>
                            </div>


                        </div> {/* End of Outer content wrapper */}

                        {/* Saved Results Slide-in Panel */}
                        <div className={`slide-in-panel ${showSavedResultsPanel ? 'open' : ''}`}>
                            <div className="flex justify-between items-center mb-6">
                                <h2 className="text-2xl font-bold text-purple-400">保存済み計算結果</h2>
                                <button
                                    onClick={() => setShowSavedResultsPanel(false)}
                                    className="text-gray-400 hover:text-gray-100 transition duration-200"
                                >
                                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path>
                                    </svg>
                                </button>
                            </div>
                            {savedSimulations.length === 0 ? (
                                <p className="text-gray-400 text-center">保存された結果はありません。</p>
                            ) : (
                                <ul className="space-y-4 flex-grow">
                                    {savedSimulations.map((item) => (
                                        <li key={item.id} className="bg-gray-800 p-4 rounded-md shadow-sm flex flex-col gap-3">
                                            <div className="flex-1">
                                                <p className="font-semibold text-gray-100 text-lg">{item.description}</p>
                                                {/* 変更点: 計算モードの表示 */}
                                                <p className="text-xs text-gray-400">
                                                    モード: {getCalculationModeDisplayName(item.calculationMode)}
                                                </p>
                                                <p className="text-xs text-gray-400">
                                                    {new Date(item.timestamp).toLocaleString()}
                                                </p>
                                            </div>
                                            <div className="flex flex-wrap gap-2">
                                                <button
                                                    onClick={() => loadSavedResultForComparison(item)}
                                                    className="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm flex-1"
                                                    disabled={loading}
                                                >
                                                    比較対象として読み込む
                                                </button>
                                                <button
                                                    onClick={() => applySavedSettings(item)}
                                                    className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm flex-1"
                                                    disabled={loading}
                                                >
                                                    設定を適用
                                                </button>
                                                <button
                                                    onClick={() => deleteSavedResultLocally(item.id, item.description)}
                                                    className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm flex-1"
                                                    disabled={loading}
                                                >
                                                    削除
                                                </button>
                                            </div>
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>
                    </div>
                </React.Fragment>
            );
        };

        // Render the React application to the HTML root element
        const root = window.ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
